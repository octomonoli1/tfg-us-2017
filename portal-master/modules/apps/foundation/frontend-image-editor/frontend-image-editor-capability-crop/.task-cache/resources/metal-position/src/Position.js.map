{"version":3,"sources":["Position.js"],"names":[],"mappings":"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","file":"../../../node_modules/metal-position/src/Position.js","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport Geometry from './Geometry';\n\n/**\n * Class with static methods responsible for doing browser position checks.\n */\nclass Position {\n\t/**\n\t * Gets the client height of the specified node. Scroll height is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientHeight(node) {\n\t\treturn this.getClientSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the client height or width of the specified node. Scroll height is\n\t * not included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getClientSize_(node, prop) {\n\t\tvar el = node;\n\t\tif (core.isWindow(node)) {\n\t\t\tel = node.document.documentElement;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tel = node.documentElement;\n\t\t}\n\t\treturn el['client' + prop];\n\t}\n\n\t/**\n\t * Gets the client width of the specified node. Scroll width is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientWidth(node) {\n\t\treturn this.getClientSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Gets the region of the element, document or window.\n\t * @param {Element|Document|Window=} opt_element Optional element to test.\n\t * @return {!DOMRect} The returned value is a simulated DOMRect object which\n\t *     is the union of the rectangles returned by getClientRects() for the\n\t *     element, i.e., the CSS border-boxes associated with the element.\n\t * @protected\n\t */\n\tstatic getDocumentRegion_(opt_element) {\n\t\tvar height = this.getHeight(opt_element);\n\t\tvar width = this.getWidth(opt_element);\n\t\treturn this.makeRegion(height, height, 0, width, 0, width);\n\t}\n\n\t/**\n\t * Gets the height of the specified node. Scroll height is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getHeight(node) {\n\t\treturn this.getSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetLeft` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetLeft` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetLeft(node, opt_ignoreTransform) {\n\t\treturn node.offsetLeft + (opt_ignoreTransform ? 0 : Position.getTranslation(node).left);\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetTop` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetTop` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetTop(node, opt_ignoreTransform) {\n\t\treturn node.offsetTop + (opt_ignoreTransform ? 0 : Position.getTranslation(node).top);\n\t}\n\n\t/**\n\t * Gets the size of an element and its position relative to the viewport.\n\t * @param {!Document|Element|Window} node\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic getRegion(node, opt_includeScroll) {\n\t\tif (core.isDocument(node) || core.isWindow(node)) {\n\t\t\treturn this.getDocumentRegion_(node);\n\t\t}\n\t\treturn this.makeRegionFromBoundingRect_(node.getBoundingClientRect(), opt_includeScroll);\n\t}\n\n\t/**\n\t * Gets the scroll left position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollLeft(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageXOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageXOffset;\n\t\t}\n\t\treturn node.scrollLeft;\n\t}\n\n\t/**\n\t * Gets the scroll top position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollTop(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageYOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageYOffset;\n\t\t}\n\t\treturn node.scrollTop;\n\t}\n\n\t/**\n\t * Gets the height or width of the specified node. Scroll height is\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getSize_(node, prop) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn this.getClientSize_(node, prop);\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tvar docEl = node.documentElement;\n\t\t\treturn Math.max(\n\t\t\t\tnode.body['scroll' + prop], docEl['scroll' + prop],\n\t\t\t\tnode.body['offset' + prop], docEl['offset' + prop], docEl['client' + prop]);\n\t\t}\n\t\treturn Math.max(node['client' + prop], node['scroll' + prop], node['offset' + prop]);\n\t}\n\n\t/**\n\t * Gets the transform matrix values for the given node.\n\t * @param {!Element} node\n\t * @return {Array<number>}\n\t */\n\tstatic getTransformMatrixValues(node) {\n\t\tvar style = getComputedStyle(node);\n\t\tvar transform = style.msTransform || style.transform || style.webkitTransform || style.mozTransform;\n\t\tif (transform !== 'none') {\n\t\t\tvar values = [];\n\t\t\tvar regex = /([\\d-\\.\\s]+)/g;\n\t\t\tvar matches = regex.exec(transform);\n\t\t\twhile (matches) {\n\t\t\t\tvalues.push(matches[1]);\n\t\t\t\tmatches = regex.exec(transform);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the number of translated pixels for the given node, for both the top and\n\t * left positions.\n\t * @param {!Element} node\n\t * @return {number}\n\t */\n\tstatic getTranslation(node) {\n\t\tvar values = Position.getTransformMatrixValues(node);\n\t\tvar translation = {\n\t\t\tleft: 0,\n\t\t\ttop: 0\n\t\t};\n\t\tif (values) {\n\t\t\ttranslation.left = parseFloat(values.length === 6 ? values[4] : values[13]);\n\t\t\ttranslation.top = parseFloat(values.length === 6 ? values[5] : values[14]);\n\t\t}\n\t\treturn translation;\n\t}\n\n\t/**\n\t * Gets the width of the specified node. Scroll width is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getWidth(node) {\n\t\treturn this.getSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Tests if a region intersects with another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic intersectRegion(r1, r2) {\n\t\treturn Geometry.intersectRect(\n\t\t\tr1.top, r1.left, r1.bottom, r1.right,\n\t\t\tr2.top, r2.left, r2.bottom, r2.right);\n\t}\n\n\t/**\n\t * Tests if a region is inside another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic insideRegion(r1, r2) {\n\t\treturn (r2.top >= r1.top) && (r2.bottom <= r1.bottom) &&\n\t\t\t(r2.right <= r1.right) && (r2.left >= r1.left);\n\t}\n\n\t/**\n\t * Tests if a region is inside viewport region.\n\t * @param {DOMRect} region\n\t * @return {boolean}\n\t */\n\tstatic insideViewport(region) {\n\t\treturn this.insideRegion(this.getRegion(window), region);\n\t}\n\n\t/**\n\t * Computes the intersection region between two regions.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {?DOMRect} Intersection region or null if regions doesn't\n\t *     intersects.\n\t */\n\tstatic intersection(r1, r2) {\n\t\tif (!this.intersectRegion(r1, r2)) {\n\t\t\treturn null;\n\t\t}\n\t\tvar bottom = Math.min(r1.bottom, r2.bottom);\n\t\tvar right = Math.min(r1.right, r2.right);\n\t\tvar left = Math.max(r1.left, r2.left);\n\t\tvar top = Math.max(r1.top, r2.top);\n\t\treturn this.makeRegion(bottom, bottom - top, left, right, top, right - left);\n\t}\n\n\t/**\n\t * Makes a region object. It's a writable version of DOMRect.\n\t * @param {number} bottom\n\t * @param {number} height\n\t * @param {number} left\n\t * @param {number} right\n\t * @param {number} top\n\t * @param {number} width\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic makeRegion(bottom, height, left, right, top, width) {\n\t\treturn {\n\t\t\tbottom: bottom,\n\t\t\theight: height,\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\ttop: top,\n\t\t\twidth: width\n\t\t};\n\t}\n\n\t/**\n\t * Makes a region from a DOMRect result from `getBoundingClientRect`.\n\t * @param  {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {DOMRect} Writable version of DOMRect.\n\t * @protected\n\t */\n\tstatic makeRegionFromBoundingRect_(rect, opt_includeScroll) {\n\t\tvar deltaX = opt_includeScroll ? Position.getScrollLeft(document) : 0;\n\t\tvar deltaY = opt_includeScroll ? Position.getScrollTop(document) : 0;\n\t\treturn this.makeRegion(\n\t\t\trect.bottom + deltaY,\n\t\t\trect.height,\n\t\t\trect.left + deltaX,\n\t\t\trect.right + deltaX,\n\t\t\trect.top + deltaY,\n\t\t\trect.width\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the given point coordinates are inside a region.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {!Object} region\n\t * @return {boolean}\n\t */\n\tstatic pointInsideRegion(x, y, region) {\n\t\treturn Position.insideRegion(region, Position.makeRegion(y, 0, x, x, y, 0));\n\t}\n}\n\nexport default Position;\n"],"sourceRoot":"/source/"}