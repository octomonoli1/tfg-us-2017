{"version":3,"sources":["core.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;KAMM;;;;;OAWE,2CAAiB;AACvB,SAAM,MAAM,+BAAN,CAAN,CADuB;;;AAXnB,OAwBE,mEAA4B,aAAa,cAAc;AAC7D,OAAI,iBAAiB,CAAC,YAAY,YAAZ,CAAD,CAAjB,CADyD;AAE7D,UAAO,YAAY,SAAZ,IAAyB,CAAC,YAAY,SAAZ,CAAsB,aAAtB,CAAoC,QAApC,CAAD,EAAgD;AAC/E,kBAAc,YAAY,SAAZ,CADiE;AAE/E,mBAAe,IAAf,CAAoB,YAAY,YAAZ,CAApB,EAF+E;IAAhF;AAIA,UAAO,cAAP,CAN6D;;;AAxBzD,OAwCE,2CAAgB,IAAI;AAC1B,OAAI,CAAC,GAAG,IAAH,EAAS;AACb,QAAI,MAAM,GAAG,QAAH,EAAN,CADS;AAEb,OAAG,IAAH,GAAU,IAAI,SAAJ,CAAc,CAAd,EAAiB,IAAI,OAAJ,CAAY,GAAZ,CAAjB,CAAV,CAFa;IAAd;AAIA,UAAO,GAAG,IAAH,CALmB;;;AAxCtB,OA2DE,yBAAO,YAAY,mBAAmB;AAC5C,OAAI,UAAJ,EAAgB;AACf,QAAI,KAAK,WAAW,KAAK,YAAL,CAAhB,CADW;AAEf,QAAI,qBAAqB,CAAC,WAAW,cAAX,CAA0B,KAAK,YAAL,CAA3B,EAA+C;AACvE,UAAK,IAAL,CADuE;KAAxE;AAGA,WAAO,OAAO,WAAW,KAAK,YAAL,CAAX,GAAgC,KAAK,gBAAL,EAAhC,CAAP,CALQ;IAAhB;AAOA,UAAO,KAAK,gBAAL,EAAP,CAR4C;;;AA3DxC,OA2EE,6CAAiB,iBAAiB;AACxC,UAAO,eAAP,CADwC;;;AA3EpC,OAoFE,+BAAU,KAAK;AACrB,UAAO,OAAO,GAAP,KAAe,SAAf,CADc;;;AApFjB,OA6FE,uBAAM,KAAK;AACjB,UAAO,QAAQ,SAAR,CADU;;;AA7Fb,OAsGE,2CAAgB,KAAK;AAC3B,UAAO,KAAK,KAAL,CAAW,GAAX,KAAmB,CAAC,KAAK,MAAL,CAAY,GAAZ,CAAD,CADC;;;AAtGvB,OA+GE,iCAAW,KAAK;AACtB,UAAO,OAAO,QAAO,iDAAP,KAAe,QAAf,IAA2B,IAAI,QAAJ,KAAiB,CAAjB,CADnB;;;AA/GlB,OAwHE,+BAAU,KAAK;AACrB,UAAO,OAAO,QAAO,iDAAP,KAAe,QAAf,IAA2B,IAAI,QAAJ,KAAiB,CAAjB,CADpB;;;AAxHjB,OAiIE,iCAAW,KAAK;AACtB,UAAO,OAAO,GAAP,KAAe,UAAf,CADe;;;AAjIlB,OA0IE,yBAAO,KAAK;AAClB,UAAO,QAAQ,IAAR,CADW;;;AA1Id,OAmJE,6BAAS,KAAK;AACpB,UAAO,OAAO,GAAP,KAAe,QAAf,CADa;;;AAnJhB,OA4JE,6BAAS,KAAK;AACpB,UAAO,QAAQ,IAAR,IAAgB,QAAQ,IAAI,MAAJ,CADX;;;AA5JhB,OAsKE,6BAAS,KAAK;AACpB,OAAI,cAAc,gDAAd,CADgB;AAEpB,UAAO,SAAS,QAAT,IAAqB,QAAQ,IAAR,IAAgB,SAAS,UAAT,CAFxB;;;AAtKhB,OAgLE,+BAAU,KAAK;AACrB,UAAO,OAAO,QAAO,iDAAP,KAAe,QAAf,IAA2B,OAAO,IAAI,IAAJ,KAAa,UAApB,CADpB;;;AAhLjB,OAyLE,6BAAS,KAAK;AACpB,UAAO,OAAO,GAAP,KAAe,QAAf,CADa;;;AAzLhB,OAyME,+DAA0B,aAAa,cAAc,aAAa;AACxE,OAAI,aAAa,eAAe,SAAf,CADuD;AAExE,OAAI,YAAY,cAAZ,CAA2B,UAA3B,CAAJ,EAA4C;AAC3C,WAAO,KAAP,CAD2C;IAA5C;;AAIA,OAAI,SAAS,KAAK,2BAAL,CAAiC,WAAjC,EAA8C,YAA9C,CAAT,CANoE;AAOxE,OAAI,WAAJ,EAAiB;AAChB,aAAS,YAAY,MAAZ,CAAT,CADgB;IAAjB;AAGA,eAAY,UAAZ,IAA0B,MAA1B,CAVwE;AAWxE,UAAO,IAAP,CAXwE;;;AAzMpE,OA2NE,uCAAe;;SA3NjB;;;;;;;;AAmON,MAAK,YAAL,GAAoB,WAAW,IAAC,CAAK,MAAL,KAAgB,GAAhB,KAAyB,CAA1B,CAAX;;;;;;;AAOpB,MAAK,gBAAL,GAAwB,CAAxB;;mBAEe","file":"../../../node_modules/metal/src/core.js","sourcesContent":["'use strict';\n\n/**\n * A collection of core utility functions.\n * @const\n */\nclass core {\n\t/**\n\t * When defining a class Foo with an abstract method bar(), you can do:\n\t * Foo.prototype.bar = core.abstractMethod\n\t *\n\t * Now if a subclass of Foo fails to override bar(), an error will be thrown\n\t * when bar() is invoked.\n\t *\n\t * @type {!Function}\n\t * @throws {Error} when invoked to indicate the method should be overridden.\n\t */\n\tstatic abstractMethod() {\n\t\tthrow Error('Unimplemented abstract method');\n\t}\n\n\t/**\n\t * Loops constructor super classes collecting its properties values. If\n\t * property is not available on the super class `undefined` will be\n\t * collected as value for the class hierarchy position.\n\t * @param {!function()} constructor Class constructor.\n\t * @param {string} propertyName Property name to be collected.\n\t * @return {Array.<*>} Array of collected values.\n\t * TODO(*): Rethink superclass loop.\n\t */\n\tstatic collectSuperClassesProperty(constructor, propertyName) {\n\t\tvar propertyValues = [constructor[propertyName]];\n\t\twhile (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {\n\t\t\tconstructor = constructor.__proto__;\n\t\t\tpropertyValues.push(constructor[propertyName]);\n\t\t}\n\t\treturn propertyValues;\n\t}\n\n\t/**\n\t * Gets the name of the given function. If the current browser doesn't\n\t * support the `name` property, this will calculate it from the function's\n\t * content string.\n\t * @param {!function()} fn\n\t * @return {string}\n\t */\n\tstatic getFunctionName(fn) {\n\t\tif (!fn.name) {\n\t\t\tvar str = fn.toString();\n\t\t\tfn.name = str.substring(9, str.indexOf('('));\n\t\t}\n\t\treturn fn.name;\n\t}\n\n\t/**\n\t * Gets an unique id. If `opt_object` argument is passed, the object is\n\t * mutated with an unique id. Consecutive calls with the same object\n\t * reference won't mutate the object again, instead the current object uid\n\t * returns. See {@link core.UID_PROPERTY}.\n\t * @param {Object=} opt_object Optional object to be mutated with the uid. If\n\t *     not specified this method only returns the uid.\n\t * @param {boolean=} opt_noInheritance Optional flag indicating if this\n\t *     object's uid property can be inherited from parents or not.\n\t * @throws {Error} when invoked to indicate the method should be overridden.\n\t */\n\tstatic getUid(opt_object, opt_noInheritance) {\n\t\tif (opt_object) {\n\t\t\tvar id = opt_object[core.UID_PROPERTY];\n\t\t\tif (opt_noInheritance && !opt_object.hasOwnProperty(core.UID_PROPERTY)) {\n\t\t\t\tid = null;\n\t\t\t}\n\t\t\treturn id || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);\n\t\t}\n\t\treturn core.uniqueIdCounter_++;\n\t}\n\n\t/**\n\t * The identity function. Returns its first argument.\n\t * @param {*=} opt_returnValue The single value that will be returned.\n\t * @return {?} The first argument.\n\t */\n\tstatic identityFunction(opt_returnValue) {\n\t\treturn opt_returnValue;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a boolean.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is boolean.\n\t */\n\tstatic isBoolean(val) {\n\t\treturn typeof val === 'boolean';\n\t}\n\n\t/**\n\t * Returns true if the specified value is not undefined.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is defined.\n\t */\n\tstatic isDef(val) {\n\t\treturn val !== undefined;\n\t}\n\n\t/**\n\t * Returns true if value is not undefined or null.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isDefAndNotNull(val) {\n\t\treturn core.isDef(val) && !core.isNull(val);\n\t}\n\n\t/**\n\t * Returns true if value is a document.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isDocument(val) {\n\t\treturn val && typeof val === 'object' && val.nodeType === 9;\n\t}\n\n\t/**\n\t * Returns true if value is a dom element.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isElement(val) {\n\t\treturn val && typeof val === 'object' && val.nodeType === 1;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a function.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is a function.\n\t */\n\tstatic isFunction(val) {\n\t\treturn typeof val === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is null.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isNull(val) {\n\t\treturn val === null;\n\t}\n\n\t/**\n\t * Returns true if the specified value is a number.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is a number.\n\t */\n\tstatic isNumber(val) {\n\t\treturn typeof val === 'number';\n\t}\n\n\t/**\n\t * Returns true if value is a window.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isWindow(val) {\n\t\treturn val !== null && val === val.window;\n\t}\n\n\t/**\n\t * Returns true if the specified value is an object. This includes arrays\n\t * and functions.\n\t * @param {?} val Variable to test.\n\t * @return {boolean} Whether variable is an object.\n\t */\n\tstatic isObject(val) {\n\t\tvar type = typeof val;\n\t\treturn type === 'object' && val !== null || type === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is a Promise.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isPromise(val) {\n\t\treturn val && typeof val === 'object' && typeof val.then === 'function';\n\t}\n\n\t/**\n\t * Returns true if value is a string.\n\t * @param {*} val\n\t * @return {Boolean}\n\t */\n\tstatic isString(val) {\n\t\treturn typeof val === 'string';\n\t}\n\n\t/**\n\t * Merges the values of a static property a class with the values of that\n\t * property for all its super classes, and stores it as a new static\n\t * property of that class. If the static property already existed, it won't\n\t * be recalculated.\n\t * @param {!function()} constructor Class constructor.\n\t * @param {string} propertyName Property name to be collected.\n\t * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled\n\t *   with the values of the property for the current class and all its super classes.\n\t *   Should return the merged value to be stored on the current class.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t */\n\tstatic mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {\n\t\tvar mergedName = propertyName + '_MERGED';\n\t\tif (constructor.hasOwnProperty(mergedName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar merged = core.collectSuperClassesProperty(constructor, propertyName);\n\t\tif (opt_mergeFn) {\n\t\t\tmerged = opt_mergeFn(merged);\n\t\t}\n\t\tconstructor[mergedName] = merged;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Null function used for default values of callbacks, etc.\n\t * @return {void} Nothing.\n\t */\n\tstatic nullFunction() {}\n}\n\n/**\n * Unique id property prefix.\n * @type {String}\n * @protected\n */\ncore.UID_PROPERTY = 'core_' + ((Math.random() * 1e9) >>> 0);\n\n/**\n * Counter for unique id.\n * @type {Number}\n * @private\n */\ncore.uniqueIdCounter_ = 1;\n\nexport default core;\n"],"sourceRoot":"/source/"}