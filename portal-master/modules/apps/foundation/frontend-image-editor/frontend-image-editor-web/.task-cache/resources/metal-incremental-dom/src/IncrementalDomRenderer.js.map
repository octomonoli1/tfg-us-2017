{"version":3,"sources":["IncrementalDomRenderer.js"],"names":[],"mappings":"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","file":"../../../node_modules/metal-incremental-dom/src/IncrementalDomRenderer.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { core, object } from 'metal';\nimport dom from 'metal-dom';\nimport { Component, ComponentRegistry, ComponentRenderer } from 'metal-component';\nimport IncrementalDomAop from './IncrementalDomAop';\nimport IncrementalDomChildren from './children/IncrementalDomChildren';\nimport IncrementalDomUnusedComponents from './cleanup/IncrementalDomUnusedComponents';\nimport IncrementalDomUtils from './utils/IncrementalDomUtils';\n\n/**\n * Class responsible for rendering components via incremental dom.\n */\nclass IncrementalDomRenderer extends ComponentRenderer {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(comp) {\n\t\tsuper(comp);\n\n\t\tcomp.context = {};\n\t\tthis.setConfig_(comp, comp.getInitialConfig());\n\t\tthis.changes_ = {};\n\t\tcomp.on('attached', this.handleAttached_.bind(this));\n\n\t\tif (!this.component_.constructor.SYNC_UPDATES_MERGED) {\n\t\t\t// If the component is being updated synchronously we'll just reuse the\n\t\t\t// `handleComponentRendererStateKeyChanged_` function from\n\t\t\t// `ComponentRenderer`.\n\t\t\tcomp.on('stateKeyChanged', this.handleStateKeyChanged_.bind(this));\n\t\t}\n\n\t\t// Binds functions that will be used many times, to avoid creating new\n\t\t// functions each time.\n\t\tthis.handleInterceptedAttributesCall_ =\n\t\t\tthis.handleInterceptedAttributesCall_.bind(this);\n\t\tthis.handleInterceptedOpenCall_ =\n\t\t\tthis.handleInterceptedOpenCall_.bind(this);\n\t\tthis.handleChildrenCaptured_ = this.handleChildrenCaptured_.bind(this);\n\t\tthis.handleChildRender_ = this.handleChildRender_.bind(this);\n\t\tthis.renderInsidePatchDontSkip_ = this.renderInsidePatchDontSkip_.bind(this);\n\t}\n\n\t/**\n\t * Attaches inline listeners found on the first component render, since those\n\t * may come from existing elements on the page that already have\n\t * data-on[eventname] attributes set to its final value. This won't trigger\n\t * `handleInterceptedAttributesCall_`, so we need manual work to guarantee\n\t * that projects using progressive enhancement like this will still work.\n\t * @param {!Element} node\n\t * @param {!Array} args\n\t * @protected\n\t */\n\tattachDecoratedListeners_(node, args) {\n\t\tif (!this.component_.wasRendered) {\n\t\t\tvar attrs = (args[2] || []).concat(args.slice(3));\n\t\t\tfor (var i = 0; i < attrs.length; i += 2) {\n\t\t\t\tvar eventName = this.getEventFromListenerAttr_(attrs[i]);\n\t\t\t\tif (eventName && !node[eventName + '__handle__']) {\n\t\t\t\t\tthis.attachEvent_(node, attrs[i], eventName, attrs[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Listens to the specified event, attached via incremental dom calls.\n\t * @param {!Element} element\n\t * @param {string} key\n\t * @param {string} eventName\n\t * @param {function()|string} fn\n\t * @protected\n\t */\n\tattachEvent_(element, key, eventName, fn) {\n\t\tvar handleKey = eventName + '__handle__';\n\t\tif (element[handleKey]) {\n\t\t\telement[handleKey].removeListener();\n\t\t\telement[handleKey] = null;\n\t\t}\n\n\t\telement[key] = fn;\n\t\tif (fn) {\n\t\t\tif (core.isString(fn)) {\n\t\t\t\tif (key[0] === 'd') {\n\t\t\t\t\t// Allow data-on[eventkey] listeners to stay in the dom, as they\n\t\t\t\t\t// won't cause conflicts.\n\t\t\t\t\telement.setAttribute(key, fn);\n\t\t\t\t}\n\t\t\t\tfn = this.component_.getListenerFn(fn);\n\t\t\t}\n\t\t\telement[handleKey] = dom.delegate(document, eventName, element, fn);\n\t\t} else {\n\t\t\telement.removeAttribute(key);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the \"children\" config property to be passed to the current\n\t * component.\n\t * @param {!Array<!Object>} children\n\t * @return {!Array<!Object>}\n\t * @protected\n\t */\n\tbuildChildren_(children) {\n\t\treturn children.length === 0 ? emptyChildren_ : children;\n\t}\n\n\t/**\n\t * Builds the key for the next component that is found.\n\t * @param {string} tag The component's tag.\n\t * @return {string}\n\t */\n\tbuildRef(tag) {\n\t\tvar ctor = core.isString(tag) ? ComponentRegistry.getConstructor(tag) : tag;\n\t\tvar prefix = this.currentPrefix_ + core.getUid(ctor, true);\n\t\tvar count = this.generatedRefCount_[prefix] || 0;\n\t\tthis.generatedRefCount_[prefix] = count + 1;\n\t\treturn prefix + 'sub' + count;\n\t}\n\n\t/**\n\t * Gets the component being currently rendered via `IncrementalDomRenderer`.\n\t * @return {Component}\n\t */\n\tstatic getComponentBeingRendered() {\n\t\treturn renderingComponents_[renderingComponents_.length - 1];\n\t}\n\n\t/**\n\t * Gets the sub component referenced by the given tag and config data,\n\t * creating it if it doesn't yet exist.\n\t * @param {string|!Function} tagOrCtor The tag name.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The sub component.\n\t * @protected\n\t */\n\tgetSubComponent_(tagOrCtor, config) {\n\t\tvar ConstructorFn = tagOrCtor;\n\t\tif (core.isString(ConstructorFn)) {\n\t\t\tConstructorFn = ComponentRegistry.getConstructor(tagOrCtor);\n\t\t}\n\n\t\tvar comp = this.component_.components[config.ref];\n\t\tif (comp && comp.constructor !== ConstructorFn) {\n\t\t\tcomp = null;\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tcomp = new ConstructorFn(config, false);\n\t\t\tthis.component_.addSubComponent(config.ref, comp);\n\t\t}\n\n\t\tif (comp.wasRendered) {\n\t\t\tthis.setConfig_(comp, config);\n\t\t\tcomp.getRenderer().startSkipUpdates();\n\t\t\tcomp.setState(config);\n\t\t\tcomp.getRenderer().stopSkipUpdates();\n\t\t}\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Guarantees that the component's element has a parent. That's necessary\n\t * when calling incremental dom's `patchOuter` for now, as otherwise it will\n\t * throw an error if the element needs to be replaced.\n\t * @return {Element} The parent, in case it was added.\n\t * @protected\n\t */\n\tguaranteeParent_() {\n\t\tvar element = this.component_.element;\n\t\tif (!element || !element.parentNode) {\n\t\t\tvar parent = document.createElement('div');\n\t\t\tif (element) {\n\t\t\t\tdom.append(parent, element);\n\t\t\t}\n\t\t\treturn parent;\n\t\t}\n\t}\n\n\t/**\n\t * Removes the most recent component from the queue of rendering components.\n\t */\n\tstatic finishedRenderingComponent() {\n\t\trenderingComponents_.pop();\n\t\tif (renderingComponents_.length === 0) {\n\t\t\tIncrementalDomUnusedComponents.disposeUnused();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `attached` listener. Stores attach data.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleAttached_(data) {\n\t\tthis.attachData_ = data;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the attributes default handler from\n\t * incremental dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {!Element} element\n\t * @param {string} name\n\t * @param {*} value\n\t * @protected\n\t */\n\thandleInterceptedAttributesCall_(originalFn, element, name, value) {\n\t\tvar eventName = this.getEventFromListenerAttr_(name);\n\t\tif (eventName) {\n\t\t\tthis.attachEvent_(element, name, eventName, value);\n\t\t\treturn;\n\t\t}\n\n\t\tif (name === 'checked') {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"checked\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily check/uncheck the element it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/198 for more details.\n\t\t\tvalue = core.isDefAndNotNull(value) && value !== false;\n\t\t}\n\n\t\tif (name === 'value' && element.value !== value) {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"value\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily update the input's content it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/239 for more details.\n\t\t\t// We only do this if the new value is different though, as otherwise the\n\t\t\t// browser will automatically move the typing cursor to the end of the\n\t\t\t// field.\n\t\t\telement[name] = value;\n\t\t}\n\n\t\tif (core.isBoolean(value)) {\n\t\t\t// Incremental dom sets boolean values as string data attributes, which\n\t\t\t// is counter intuitive. This changes the behavior to use the actual\n\t\t\t// boolean value.\n\t\t\telement[name] = value;\n\t\t\tif (value) {\n\t\t\t\telement.setAttribute(name, '');\n\t\t\t} else {\n\t\t\t\telement.removeAttribute(name);\n\t\t\t}\n\t\t} else {\n\t\t\toriginalFn(element, name, value);\n\t\t}\n\t}\n\n\t/**\n\t * Handles the event of children having finished being captured.\n\t * @param {!Object} The captured children in tree format.\n\t * @protected\n\t */\n\thandleChildrenCaptured_(tree) {\n\t\tvar {config, tag} = this.componentToRender_;\n\t\tconfig.children = this.buildChildren_(tree.config.children);\n\t\tthis.componentToRender_ = null;\n\t\tthis.currentPrefix_ = this.prevPrefix_;\n\t\tthis.prevPrefix_ = null;\n\t\tthis.renderFromTag_(tag, config);\n\t}\n\n\t/**\n\t * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n\t * component nodes so that they can be rendered the correct way without\n\t * having to recapture both them and their children via incremental dom.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t * @protected\n\t */\n\thandleChildRender_(node) {\n\t\tif (node.tag && IncrementalDomUtils.isComponentTag(node.tag)) {\n\t\t\tnode.config.children = this.buildChildren_(node.config.children);\n\t\t\tthis.renderFromTag_(node.tag, node.config);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `stateKeyChanged` event. Overrides original method from\n\t * `ComponentRenderer` to guarantee that `IncrementalDomRenderer`'s logic\n\t * will run first.\n\t * @param {!Object} data\n\t * @override\n\t * @protected\n\t */\n\thandleComponentRendererStateKeyChanged_(data) {\n\t\tthis.handleStateKeyChanged_(data);\n\t\tsuper.handleComponentRendererStateKeyChanged_(data);\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedOpenCall_(originalFn, tag) {\n\t\tif (IncrementalDomUtils.isComponentTag(tag)) {\n\t\t\treturn this.handleSubComponentCall_.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.handleRegularCall_.apply(this, arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a regular element. Adds any inline listeners found and makes\n\t * sure that component root elements are always reused.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleRegularCall_(originalFn, ...args) {\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_ && currComp.config.key) {\n\t\t\targs[1] = currComp.config.key;\n\t\t}\n\n\t\tvar node = originalFn.apply(null, args);\n\t\tthis.attachDecoratedListeners_(node, args);\n\t\tthis.updateElementIfNotReached_(node);\n\t\treturn node;\n\t}\n\n\t/**\n\t * Handles the `stateKeyChanged` event. Stores state properties that have\n\t * changed since the last render.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleStateKeyChanged_(data) {\n\t\tthis.changes_[data.key] = data;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a sub component element. Creates and updates the appropriate\n\t * sub component.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @protected\n\t */\n\thandleSubComponentCall_(originalFn, ...args) {\n\t\tvar config = IncrementalDomUtils.buildConfigFromCall(args);\n\t\tconfig.ref = core.isDefAndNotNull(config.ref) ? config.ref : this.buildRef(args[0]);\n\t\tthis.componentToRender_ = {\n\t\t\tconfig,\n\t\t\ttag: args[0]\n\t\t};\n\n\t\tthis.prevPrefix_ = this.currentPrefix_;\n\t\tthis.currentPrefix_ = config.ref;\n\t\tthis.generatedRefCount_[this.currentPrefix_] = 0;\n\t\tIncrementalDomChildren.capture(this, this.handleChildrenCaptured_);\n\t}\n\n\t/**\n\t * Intercepts incremental dom calls from this component.\n\t * @protected\n\t */\n\tintercept_() {\n\t\tIncrementalDomAop.startInterception({\n\t\t\tattributes: this.handleInterceptedAttributesCall_,\n\t\t\telementOpen: this.handleInterceptedOpenCall_\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the given object is an incremental dom node.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t */\n\tstatic isIncDomNode(node) {\n\t\treturn !!node[IncrementalDomChildren.CHILD_OWNER];\n\t}\n\n\t/**\n\t * Returns the event name if the given attribute is a listener (of the form\n\t * \"on<EventName>\"), or null if it isn't.\n\t * @param {string} attr\n\t * @return {?string}\n\t * @protected\n\t */\n\tgetEventFromListenerAttr_(attr) {\n\t\tvar matches = IncrementalDomRenderer.LISTENER_REGEX.exec(attr);\n\t\tvar eventName = matches ? (matches[1] ? matches[1] : matches[2]) : null;\n\t\treturn eventName ? eventName.toLowerCase() : null;\n\t}\n\n\t/**\n\t * Gets the component that is this component's parent (that is, the one that\n\t * actually rendered it), or null if there's no parent.\n\t * @return {Component}\n\t */\n\tgetParent() {\n\t\treturn this.parent_;\n\t}\n\n\t/**\n\t * Gets the component that is this component's owner (that is, the one that\n\t * passed its config properties and holds its ref), or null if there's none.\n\t * @return {Component}\n\t */\n\tgetOwner() {\n\t\treturn this.owner_;\n\t}\n\n\t/**\n\t * Creates and renders the given function, which can either be a simple\n\t * incremental dom function or a component constructor.\n\t * @param {!function()} fnOrCtor Either be a simple incremental dom function\n\t or a component constructor.\n\t * @param {Object|Element=} opt_dataOrElement Optional config data for the\n\t *     function or parent for the rendered content.\n\t * @param {Element=} opt_element Optional parent for the rendered content.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\tstatic render(fnOrCtor, opt_dataOrElement, opt_parent) {\n\t\tif (!Component.isComponentCtor(fnOrCtor)) {\n\t\t\tvar fn = fnOrCtor;\n\t\t\tclass TempComponent extends Component {\n\t\t\t\tcreated() {\n\t\t\t\t\tif (IncrementalDomRenderer.getComponentBeingRendered()) {\n\t\t\t\t\t\tthis.getRenderer().updateContext_(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trender() {\n\t\t\t\t\tfn(this.config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTempComponent.RENDERER = IncrementalDomRenderer;\n\t\t\tfnOrCtor = TempComponent;\n\t\t}\n\t\treturn Component.render(fnOrCtor, opt_dataOrElement, opt_parent);\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`.\n\t */\n\trender() {\n\t\tthis.patch();\n\t}\n\n\t/**\n\t * Renders the given child node via its owner renderer.\n\t * @param {!Object} child\n\t */\n\tstatic renderChild(child) {\n\t\tchild[IncrementalDomChildren.CHILD_OWNER].renderChild(child);\n\t}\n\n\t/**\n\t * Renders the given child node.\n\t * @param {!Object} child\n\t */\n\trenderChild(child) {\n\t\tthis.intercept_();\n\t\tIncrementalDomChildren.render(child, this.handleChildRender_);\n\t\tIncrementalDomAop.stopInterception();\n\t}\n\n\t/**\n\t * Renders the contents for the given tag.\n\t * @param {!function()|string} tag\n\t * @param {!Object} config\n\t * @protected\n\t */\n\trenderFromTag_(tag, config) {\n\t\tif (core.isString(tag) || tag.prototype.getRenderer) {\n\t\t\tvar comp = this.renderSubComponent_(tag, config);\n\t\t\tthis.updateElementIfNotReached_(comp.element);\n\t\t\treturn comp.element;\n\t\t} else {\n\t\t\treturn tag(config);\n\t\t}\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t */\n\trenderIncDom() {\n\t\tif (this.component_.render) {\n\t\t\tthis.component_.render();\n\t\t} else {\n\t\t\tIncrementalDOM.elementVoid('div');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, but\n\t * doesn't call `patch` yet. Rather, this will be the function that should be\n\t * called by `patch`.\n\t */\n\trenderInsidePatch() {\n\t\tif (this.component_.wasRendered &&\n\t\t\t!this.shouldUpdate(this.changes_) &&\n\t\t\tIncrementalDOM.currentPointer() === this.component_.element) {\n\t\t\tif (this.component_.element) {\n\t\t\t\tIncrementalDOM.skipNode();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.renderInsidePatchDontSkip_();\n\t}\n\n\t/**\n\t * The same as `renderInsidePatch`, but without the check that may skip the\n\t * render action.\n\t * @protected\n\t */\n\trenderInsidePatchDontSkip_() {\n\t\tIncrementalDomRenderer.startedRenderingComponent(this.component_);\n\t\tthis.changes_ = {};\n\t\tthis.rootElementReached_ = false;\n\t\tIncrementalDomUnusedComponents.schedule(this.childComponents_ || []);\n\t\tthis.childComponents_ = [];\n\t\tthis.generatedRefCount_ = {};\n\t\tthis.listenersToAttach_ = [];\n\t\tthis.currentPrefix_ = '';\n\t\tthis.intercept_();\n\t\tthis.renderIncDom();\n\t\tIncrementalDomAop.stopInterception();\n\t\tif (!this.rootElementReached_) {\n\t\t\tthis.component_.element = null;\n\t\t} else {\n\t\t\tthis.component_.addElementClasses();\n\t\t}\n\t\tthis.emit('rendered', !this.isRendered_);\n\t\tIncrementalDomRenderer.finishedRenderingComponent();\n\t}\n\n\t/**\n\t * This updates the sub component that is represented by the given data.\n\t * The sub component is created, added to its parent and rendered. If it\n\t * had already been rendered before though, it will only have its state\n\t * updated instead.\n\t * @param {string|!function()} tagOrCtor The tag name or constructor function.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The updated sub component.\n\t * @protected\n\t */\n\trenderSubComponent_(tagOrCtor, config) {\n\t\tvar comp = this.getSubComponent_(tagOrCtor, config);\n\t\tthis.updateContext_(comp);\n\t\tvar renderer = comp.getRenderer();\n\t\tif (renderer instanceof IncrementalDomRenderer) {\n\t\t\tvar parentComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\t\tparentComp.getRenderer().childComponents_.push(comp);\n\t\t\trenderer.parent_ = parentComp;\n\t\t\trenderer.owner_ = this.component_;\n\t\t\trenderer.renderInsidePatch();\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'IncrementalDomRenderer doesn\\'t support rendering sub components ' +\n\t\t\t\t'that don\\'t use IncrementalDomRenderer as well, like:',\n\t\t\t\tcomp\n\t\t\t);\n\t\t}\n\t\tif (!comp.wasRendered) {\n\t\t\tcomp.renderAsSubComponent();\n\t\t}\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Sets the component's config object with its new value.\n\t * @param {!Component} comp The component to set the config for.\n\t * @param {!Object} config\n\t * @protected\n\t */\n\tsetConfig_(comp, config) {\n\t\tvar prevConfig = comp.config;\n\t\tcomp.config = config;\n\t\tif (core.isFunction(comp.configChanged)) {\n\t\t\tcomp.configChanged(config, prevConfig || {});\n\t\t}\n\t\tcomp.emit('configChanged', {\n\t\t\tprevVal: prevConfig,\n\t\t\tnewVal: config\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * Can be overridden by subclasses or implemented by components to provide\n\t * customized behavior (only updating when a state property used by the\n\t * template changes, for example).\n\t * @param {!Object} changes\n\t * @return {boolean}\n\t */\n\tshouldUpdate(changes) {\n\t\tif (this.component_.shouldUpdate) {\n\t\t\treturn this.component_.shouldUpdate(changes);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stores the component that has just started being rendered.\n\t * @param {!Component} comp\n\t */\n\tstatic startedRenderingComponent(comp) {\n\t\trenderingComponents_.push(comp);\n\t}\n\n\t/**\n\t * Patches the component's element with the incremental dom function calls\n\t * done by `renderIncDom`.\n\t */\n\tpatch() {\n\t\tif (!this.component_.element && this.parent_) {\n\t\t\t// If the component has no content but was rendered from another component,\n\t\t\t// we'll need to patch this parent to make sure that any new content will\n\t\t\t// be added in the right place.\n\t\t\tthis.parent_.getRenderer().patch();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tempParent = this.guaranteeParent_();\n\t\tif (tempParent) {\n\t\t\tIncrementalDOM.patch(tempParent, this.renderInsidePatchDontSkip_);\n\t\t\tdom.exitDocument(this.component_.element);\n\t\t\tif (this.component_.element && this.component_.inDocument) {\n\t\t\t\tthis.component_.renderElement_(\n\t\t\t\t\tthis.attachData_.parent,\n\t\t\t\t\tthis.attachData_.sibling\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tvar element = this.component_.element;\n\t\t\tIncrementalDOM.patchOuter(element, this.renderInsidePatchDontSkip_);\n\t\t\tif (!this.component_.element) {\n\t\t\t\tdom.exitDocument(element);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`. Makes\n\t * sure that it won't cause a rerender if the only change was for the\n\t * \"element\" property.\n\t */\n\tupdate() {\n\t\tif (this.hasChangedBesidesElement_(this.changes_) &&\n\t\t\tthis.shouldUpdate(this.changes_)) {\n\t\t\tthis.patch();\n\t\t}\n\t}\n\n\t/**\n\t * Updates this renderer's component's element with the given values, unless\n\t * it has already been reached by an earlier call.\n\t * @param {!Element} node\n\t * @protected\n\t */\n\tupdateElementIfNotReached_(node) {\n\t\tvar currComp = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar currRenderer = currComp.getRenderer();\n\t\tif (!currRenderer.rootElementReached_) {\n\t\t\tcurrRenderer.rootElementReached_ = true;\n\t\t\tif (currComp.element !== node) {\n\t\t\t\tcurrComp.element = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the given component's context according to the data from the\n\t * component that is currently being rendered.\n\t * @param {!Component} comp\n\t * @protected\n\t */\n\tupdateContext_(comp) {\n\t\tvar context = comp.context;\n\t\tvar parent = IncrementalDomRenderer.getComponentBeingRendered();\n\t\tvar childContext = parent.getChildContext ? parent.getChildContext() : {};\n\t\tobject.mixin(context, parent.context, childContext);\n\t\tcomp.context = context;\n\t}\n}\n\nvar renderingComponents_ = [];\nvar emptyChildren_ = [];\n\nIncrementalDomRenderer.LISTENER_REGEX = /^(?:on([A-Z]\\w+))|(?:data-on(\\w+))$/;\n\nexport default IncrementalDomRenderer;\n"],"sourceRoot":"/source/"}