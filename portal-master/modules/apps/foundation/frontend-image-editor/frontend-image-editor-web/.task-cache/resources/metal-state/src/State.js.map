{"version":3,"sources":["State.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAaM;;;AACL,WADK,KACL,CAAY,UAAZ,EAAwB;yBADnB,OACmB;;gDACvB,0BADuB;;;;;;;;AASvB,SAAK,mBAAL,GAA2B,IAA3B;;;;;;;AATuB,QAgBvB,CAAK,UAAL,GAAkB,EAAlB,CAhBuB;;AAkBvB,SAAK,kBAAL,CAAwB,IAAxB,EAlBuB;AAmBvB,SAAK,iBAAL,GAnBuB;AAoBvB,SAAK,yBAAL,CAA+B,UAA/B,EApBuB;;GAAxB;;;;;;;;;;;AADK,kBA+BL,uCAAc,MAAM,QAAQ,cAAc;AACzC,QAAK,aAAL,CAAmB,IAAnB,EAAyB,MAAzB,EAAiC,YAAjC,EADyC;AAEzC,UAAO,cAAP,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC,KAAK,oBAAL,CAA0B,IAA1B,CAAlC,EAFyC;;;AA/BrC,kBAsEL,iCAAW,eAAe,2BAA2B,2BAA2B;AAC/E,OAAI,YAAK,QAAL,CAAc,aAAd,CAAJ,EAAkC;AACjC,WAAO,KAAK,aAAL,CACN,aADM,EAEN,yBAFM,EAGN,yBAHM,CAAP,CADiC;IAAlC;;AAQA,OAAI,gBAAgB,6BAA6B,EAA7B,CAT2D;AAU/E,OAAI,QAAQ,OAAO,IAAP,CAAY,aAAZ,CAAR,CAV2E;;AAY/E,OAAI,QAAQ,EAAR,CAZ2E;AAa/E,QAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,MAAM,MAAN,EAAc,GAAlC,EAAuC;AACtC,QAAI,OAAO,MAAM,CAAN,CAAP,CADkC;AAEtC,SAAK,aAAL,CAAmB,IAAnB,EAAyB,cAAc,IAAd,CAAzB,EAA8C,cAAc,IAAd,CAA9C,EAFsC;AAGtC,UAAM,IAAN,IAAc,KAAK,oBAAL,CAA0B,IAA1B,CAAd,CAHsC;IAAvC;;AAMA,OAAI,8BAA8B,KAA9B,EAAqC;AACxC,WAAO,gBAAP,CAAwB,6BAA6B,IAA7B,EAAmC,KAA3D,EADwC;IAAzC;;;AAzFI,kBAoGL,+DAA0B,YAAY;AACrC,OAAI,OAAO,KAAK,WAAL,CAD0B;AAErC,OAAI,gBAAgB,KAAhB,CAFiC;AAGrC,OAAI,MAAM,gBAAN,CAAuB,IAAvB,CAAJ,EAAkC;AACjC,oBAAgB,KAAK,SAAL,CADiB;IAAlC;AAGA,QAAK,UAAL,CAAgB,KAAK,YAAL,EAAmB,UAAnC,EAA+C,aAA/C,EANqC;;;AApGjC,kBAoHL,6DAAyB,MAAM;AAC9B,OAAI,KAAK,WAAL,CAAiB,mBAAjB,CAAqC,IAArC,CAAJ,EAAgD;AAC/C,UAAM,IAAI,KAAJ,CAAU,4DAA4D,IAA5D,GAAmE,IAAnE,CAAhB,CAD+C;IAAhD;;;AArHI,kBAiIL,uCAAc,MAAM,QAAQ,cAAc;AACzC,QAAK,wBAAL,CAA8B,IAA9B,EADyC;;AAGzC,QAAK,UAAL,CAAgB,IAAhB,IAAwB;AACvB,YAAQ,UAAU,EAAV;AACR,kBAAc,YAAd;AACA,WAAO,MAAM,SAAN,CAAgB,aAAhB;IAHR,CAHyC;;;AAjIrC,kBAiJL,qDAAqB,MAAM;AAC1B,UAAO;AACN,kBAAc,IAAd;AACA,gBAAY,IAAZ;AACA,SAAK,eAAW;AACf,YAAO,KAAK,iBAAL,CAAuB,IAAvB,CAAP,CADe;KAAX;AAGL,SAAK,aAAS,GAAT,EAAc;AAClB,UAAK,iBAAL,CAAuB,IAAvB,EAA6B,GAA7B,EADkB;KAAd;IANN,CAD0B;;;AAjJtB,kBAuKL,uCAAc,IAAI,MAAM;AACvB,OAAI,YAAK,QAAL,CAAc,EAAd,CAAJ,EAAuB;AACtB,WAAO,KAAK,EAAL,EAAS,KAAT,CAAe,IAAf,EAAqB,IAArB,CAAP,CADsB;IAAvB,MAEO,IAAI,YAAK,UAAL,CAAgB,EAAhB,CAAJ,EAAyB;AAC/B,WAAO,GAAG,KAAH,CAAS,IAAT,EAAe,IAAf,CAAP,CAD+B;IAAzB;;;AA1KH,kBAuLL,mCAAY,MAAM,OAAO,cAAc;AACtC,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADkC;AAEtC,OAAI,SAAS,KAAK,MAAL,CAFyB;AAGtC,OAAI,OAAO,MAAP,EAAe;AAClB,YAAQ,KAAK,aAAL,CAAmB,OAAO,MAAP,EAAe,CAAC,KAAD,EAAQ,YAAR,CAAlC,CAAR,CADkB;IAAnB;AAGA,UAAO,KAAP,CANsC;;;AAvLlC,kBAwML,yCAAe,MAAM,OAAO;AAC3B,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADuB;AAE3B,OAAI,SAAS,KAAK,MAAL,CAFc;AAG3B,OAAI,OAAO,SAAP,EAAkB;AACrB,QAAI,kBAAkB,KAAK,aAAL,CAAmB,OAAO,SAAP,EAAkB,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,CAArC,CAAlB,CADiB;;AAGrB,QAAI,2BAA2B,KAA3B,EAAkC;AACrC,aAAQ,KAAR,eAA0B,eAA1B,EADqC;KAAtC;AAGA,WAAO,eAAP,CANqB;IAAtB;AAQA,UAAO,IAAP,CAX2B;;;AAxMvB,kBA2NL,mCAAY,MAAM;AACjB,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADa;AAEjB,UAAO,CAAC,KAAK,MAAL,CAAY,SAAZ,IAAyB,CAAC,KAAK,OAAL,CAFjB;;;AA3Nb,kBAmOL,6CAAkB;AACjB,2BAAM,eAAN,YADiB;AAEjB,QAAK,UAAL,GAAkB,IAAlB,CAFiB;AAGjB,QAAK,mBAAL,GAA2B,IAA3B,CAHiB;;;AAnOb,kBA6OL,6CAAkB;AACjB,OAAI,CAAC,KAAK,UAAL,EAAD,EAAoB;AACvB,QAAI,OAAO,KAAK,mBAAL,CADY;AAEvB,SAAK,mBAAL,GAA2B,IAA3B,CAFuB;AAGvB,SAAK,IAAL,CAAU,cAAV,EAA0B,IAA1B,EAHuB;IAAxB;;;AA9OI,kBA6PL,mBAAI,MAAM;AACT,UAAO,KAAK,IAAL,CAAP,CADS;;;AA7PL,kBAuQL,6BAAS,WAAW;AACnB,OAAI,QAAQ,EAAR,CADe;AAEnB,OAAI,QAAQ,aAAa,KAAK,YAAL,EAAb,CAFO;;AAInB,QAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,MAAM,MAAN,EAAc,GAAlC,EAAuC;AACtC,UAAM,MAAM,CAAN,CAAN,IAAkB,KAAK,MAAM,CAAN,CAAL,CAAlB,CADsC;IAAvC;;AAIA,UAAO,KAAP,CARmB;;;AAvQf,kBAwRL,+CAAkB,MAAM;AACvB,UAAO,CAAC,KAAK,UAAL,CAAgB,IAAhB,KAAyB,EAAzB,CAAD,CAA8B,MAA9B,CADgB;;;AAxRnB,kBAgSL,uCAAe;AACd,UAAO,OAAO,IAAP,CAAY,KAAK,UAAL,CAAnB,CADc;;;AAhSV,kBA2SL,+CAAkB,MAAM;AACvB,QAAK,aAAL,CAAmB,IAAnB,EADuB;AAEvB,UAAO,KAAK,UAAL,CAAgB,IAAhB,EAAsB,KAAtB,CAFgB;;;AA3SnB,kBAsTL,iCAAW,MAAM;AAChB,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADY;AAEhB,UAAO,KAAK,KAAL,KAAe,MAAM,SAAN,CAAgB,WAAhB,IAA+B,KAAK,YAAL,CAFrC;;;AAtTZ,kBAgUL,mCAAY,KAAK;AAChB,UAAO,CAAC,CAAC,KAAK,UAAL,CAAgB,GAAhB,CAAD,CADQ;;;AAhUZ,kBA2UL,uCAAc,MAAM,SAAS;AAC5B,OAAI,KAAK,mBAAL,CAAyB,IAAzB,EAA+B,OAA/B,CAAJ,EAA6C;AAC5C,QAAI,OAAO;AACV,UAAK,IAAL;AACA,aAAQ,KAAK,IAAL,CAAR;AACA,cAAS,OAAT;KAHG,CADwC;AAM5C,SAAK,IAAL,CAAU,OAAO,SAAP,EAAkB,IAA5B,EAN4C;AAO5C,SAAK,IAAL,CAAU,iBAAV,EAA6B,IAA7B,EAP4C;AAQ5C,SAAK,mBAAL,CAAyB,IAAzB,EAR4C;IAA7C;;;AA5UI,kBA6VL,uCAAc,MAAM;AACnB,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADe;AAEnB,OAAI,KAAK,KAAL,KAAe,MAAM,SAAN,CAAgB,aAAhB,EAA+B;AACjD,WADiD;IAAlD;;AAIA,QAAK,KAAL,GAAa,MAAM,SAAN,CAAgB,YAAhB,CANM;AAOnB,QAAK,gBAAL,CAAsB,IAAtB,EAPmB;AAQnB,OAAI,CAAC,KAAK,OAAL,EAAc;AAClB,SAAK,KAAL,GAAa,MAAM,SAAN,CAAgB,oBAAhB,CADK;AAElB,SAAK,gBAAL,CAAsB,IAAtB,EAFkB;IAAnB;AAIA,QAAK,KAAL,GAAa,MAAM,SAAN,CAAgB,WAAhB,CAZM;;;AA7Vf,QAmXE,mCAAY,QAAQ;AAC1B,UAAO,cAAO,KAAP,CAAa,KAAb,CAAmB,IAAnB,EAAyB,CAAC,EAAD,EAAK,MAAL,CAAY,OAAO,OAAP,EAAZ,CAAzB,CAAP,CAD0B;;;AAnXtB,QA6XE,6CAAiB,MAAM;AAC7B,UAAO,YAAK,yBAAL,CAA+B,IAA/B,EAAqC,OAArC,EAA8C,MAAM,WAAN,CAArD,CAD6B;;;AA7XzB,kBAsYL,iDAAoB;AACnB,eAAK,yBAAL,CAA+B,KAAK,WAAL,EAAkB,cAAjD,EAAiE,UAAS,MAAT,EAAiB;AACjF,WAAO,aAAM,OAAN,CAAc,MAAd,EAAsB,MAAtB,CAA6B,UAAS,MAAT,EAAiB,GAAjB,EAAsB;AACzD,SAAI,GAAJ,EAAS;AACR,aAAO,GAAP,IAAc,IAAd,CADQ;MAAT;AAGA,YAAO,MAAP,CAJyD;KAAtB,EAKjC,EALI,CAAP,CADiF;IAAjB,CAAjE,CADmB;;;AAtYf,kBAqZL,yCAAe,MAAM;AACpB,QAAK,UAAL,CAAgB,IAAhB,IAAwB,IAAxB,CADoB;AAEpB,UAAO,KAAK,IAAL,CAAP,CAFoB;;;AArZhB,kBA+ZL,mDAAoB,YAAY;AAC/B,OAAI,CAAC,KAAK,mBAAL,EAA0B;AAC9B,iBAAM,QAAN,CAAe,KAAK,eAAL,EAAsB,IAArC,EAD8B;AAE9B,SAAK,mBAAL,GAA2B;AAC1B,cAAS,EAAT;KADD,CAF8B;IAA/B;;AAOA,OAAI,OAAO,WAAW,GAAX,CARoB;AAS/B,OAAI,UAAU,KAAK,mBAAL,CAAyB,OAAzB,CATiB;AAU/B,OAAI,QAAQ,IAAR,CAAJ,EAAmB;AAClB,YAAQ,IAAR,EAAc,MAAd,GAAuB,WAAW,MAAX,CADL;IAAnB,MAEO;AACN,YAAQ,IAAR,IAAgB,UAAhB,CADM;IAFP;;;AAzaI,kBAybL,mBAAI,MAAM,OAAO;AAChB,OAAI,KAAK,WAAL,CAAiB,IAAjB,CAAJ,EAA4B;AAC3B,SAAK,IAAL,IAAa,KAAb,CAD2B;IAA5B;;;AA1bI,kBAqcL,6CAAiB,MAAM;AACtB,OAAI,SAAS,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CADS;;AAGtB,OAAI,OAAO,KAAP,KAAiB,SAAjB,EAA4B;AAC/B,SAAK,IAAL,IAAa,OAAO,KAAP,CADkB;IAAhC,MAEO;AACN,SAAK,IAAL,IAAa,KAAK,aAAL,CAAmB,OAAO,OAAP,CAAhC,CADM;IAFP;;;AAxcI,kBAqdL,6CAAiB,MAAM;AACtB,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CADkB;AAEtB,OAAI,KAAK,YAAL,KAAsB,SAAtB,EAAiC;AACpC,SAAK,IAAL,IAAa,KAAK,YAAL,CADuB;AAEpC,SAAK,YAAL,GAAoB,SAApB,CAFoC;IAArC;;;AAvdI,kBAoeL,6BAAS,QAAQ,cAAc;;;AAC9B,UAAO,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B;WAAQ,OAAK,GAAL,CAAS,IAAT,EAAe,OAAO,IAAP,CAAf;IAAR,CAA5B,CAD8B;AAE9B,OAAI,gBAAgB,KAAK,mBAAL,EAA0B;AAC7C,SAAK,IAAL,CAAU,cAAV,EAA0B,YAA1B,EAD6C;IAA9C;;;AAteI,kBAmfL,+CAAkB,MAAM,OAAO;AAC9B,OAAI,CAAC,KAAK,WAAL,CAAiB,IAAjB,CAAD,IAA2B,CAAC,KAAK,iBAAL,CAAuB,IAAvB,EAA6B,KAA7B,CAAD,EAAsC;AACpE,WADoE;IAArE;;AAIA,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CAL0B;AAM9B,OAAI,KAAK,YAAL,KAAsB,SAAtB,IAAmC,KAAK,KAAL,KAAe,MAAM,SAAN,CAAgB,aAAhB,EAA+B;AACpF,SAAK,KAAL,GAAa,MAAM,SAAN,CAAgB,WAAhB,CADuE;IAArF;;AAIA,OAAI,UAAU,KAAK,IAAL,CAAV,CAV0B;AAW9B,QAAK,KAAL,GAAa,KAAK,WAAL,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,OAA9B,CAAb,CAX8B;AAY9B,QAAK,OAAL,GAAe,IAAf,CAZ8B;AAa9B,QAAK,aAAL,CAAmB,IAAnB,EAAyB,OAAzB,EAb8B;;;AAnf1B,kBA+gBL,mDAAoB,MAAM,SAAS;AAClC,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CAD8B;AAElC,UAAO,IAAC,CAAK,KAAL,KAAe,MAAM,SAAN,CAAgB,WAAhB,KACrB,YAAK,QAAL,CAAc,OAAd,KAA0B,YAAY,KAAK,IAAL,CAAZ,CADrB,CAF2B;;;AA/gB9B,kBA6hBL,+CAAkB,MAAM,OAAO;AAC9B,OAAI,OAAO,KAAK,UAAL,CAAgB,IAAhB,CAAP,CAD0B;;AAG9B,UAAO,KAAK,KAAL,KAAe,MAAM,SAAN,CAAgB,oBAAhB,IACrB,KAAK,cAAL,CAAoB,IAApB,EAA0B,KAA1B,CADM,CAHuB;;;SA7hB1B;;;;;;;;;AA2iBN,OAAM,YAAN,GAAqB,CAAC,OAAD,EAAU,UAAV,CAArB;;;;;;AAMA,OAAM,SAAN,GAAkB;AACjB,iBAAe,CAAf;AACA,gBAAc,CAAd;AACA,wBAAsB,CAAtB;AACA,eAAa,CAAb;EAJD;;mBAOe","file":"../../../node_modules/metal-state/src/State.js","sourcesContent":["'use strict';\n\nimport { array, async, core, object } from 'metal';\nimport { EventEmitter } from 'metal-events';\n\n/**\n * State adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `addToState` method for a complete list of available configuration\n * options for each state key.\n * @constructor\n * @extends {EventEmitter}\n */\nclass State extends EventEmitter {\n\tconstructor(opt_config) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Object with information about the batch event that is currently\n\t\t * scheduled, or null if none is.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledBatchData_ = null;\n\n\t\t/**\n\t\t * Object that contains information about all this instance's state keys.\n\t\t * @type {!Object<string, !Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.stateInfo_ = {};\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.mergeInvalidKeys_();\n\t\tthis.addToStateFromStaticHint_(opt_config);\n\t}\n\n\t/**\n\t * Adds the given key to the state.\n\t * @param {string} name The name of the new state key.\n\t * @param {Object.<string, *>=} config The configuration object for the new\n\t *     key. See `addToState` for supported settings.\n\t * @param {*} initialValue The initial value of the new key.\n\t */\n\taddKeyToState(name, config, initialValue) {\n\t\tthis.buildKeyInfo_(name, config, initialValue);\n\t\tObject.defineProperty(this, name, this.buildKeyPropertyDef_(name));\n\t}\n\n\t/**\n\t * Adds the given key(s) to the state, together with its(their) configs.\n\t * Config objects support the given settings:\n\t *     setter - Function for normalizing state key values. It receives the new\n\t *     value that was set, and returns the value that should be stored.\n\t *\n\t *     validator - Function that validates state key values. When it returns\n\t *     false, the new value is ignored. When it returns an instance of Error,\n\t *     it will emit the error to the console.\n\t *\n\t *     value - The default value for the state key. Note that setting this to\n\t *     an object will cause all class instances to use the same reference to\n\t *     the object. To have each instance use a different reference for objects,\n\t *     use the `valueFn` option instead.\n\t *\n\t *     valueFn - A function that returns the default value for a state key.\n\t *\n\t *     writeOnce - Ignores writes to the state key after it's been first\n\t *     written to. That is, allows writes only when setting the value for the\n\t *     first time.\n\t * @param {!Object.<string, !Object>|string} configsOrName An object that maps\n\t *     configuration options for keys to be added to the state or the name of\n\t *     a single key to be added.\n\t * @param {Object.<string, *>=} opt_initialValuesOrConfig An object that maps\n\t *     state keys to their initial values. These values have higher precedence\n\t *     than the default values specified in the configurations. If a single\n\t *     key name was passed as the first param instead though, then this should\n\t *     be the configuration object for that key.\n\t * @param {boolean|Object|*=} opt_contextOrInitialValue If the first\n\t *     param passed to this method was a config object, this should be the\n\t *     context where the added state keys will be defined (defaults to `this`),\n\t *     or false if they shouldn't be defined at all. If the first param was a\n\t *     single key name though, this should be its initial value.\n\t */\n\taddToState(configsOrName, opt_initialValuesOrConfig, opt_contextOrInitialValue) {\n\t\tif (core.isString(configsOrName)) {\n\t\t\treturn this.addKeyToState(\n\t\t\t\tconfigsOrName,\n\t\t\t\topt_initialValuesOrConfig,\n\t\t\t\topt_contextOrInitialValue\n\t\t\t);\n\t\t}\n\n\t\tvar initialValues = opt_initialValuesOrConfig || {};\n\t\tvar names = Object.keys(configsOrName);\n\n\t\tvar props = {};\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tvar name = names[i];\n\t\t\tthis.buildKeyInfo_(name, configsOrName[name], initialValues[name]);\n\t\t\tprops[name] = this.buildKeyPropertyDef_(name);\n\t\t}\n\n\t\tif (opt_contextOrInitialValue !== false) {\n\t\t\tObject.defineProperties(opt_contextOrInitialValue || this, props);\n\t\t}\n\t}\n\n\t/**\n\t * Adds state keys from super classes static hint `MyClass.STATE = {};`.\n\t * @param {Object.<string, !Object>=} opt_config An object that maps all the\n\t *     configurations for state keys.\n\t * @protected\n\t */\n\taddToStateFromStaticHint_(opt_config) {\n\t\tvar ctor = this.constructor;\n\t\tvar defineContext = false;\n\t\tif (State.mergeStateStatic(ctor)) {\n\t\t\tdefineContext = ctor.prototype;\n\t\t}\n\t\tthis.addToState(ctor.STATE_MERGED, opt_config, defineContext);\n\t}\n\n\t/**\n\t * Checks that the given name is a valid state key name. If it's not, an error\n\t * will be thrown.\n\t * @param {string} name The name to be validated.\n\t * @throws {Error}\n\t * @protected\n\t */\n\tassertValidStateKeyName_(name) {\n\t\tif (this.constructor.INVALID_KEYS_MERGED[name]) {\n\t\t\tthrow new Error('It\\'s not allowed to create a state key with the name \"' + name + '\".');\n\t\t}\n\t}\n\n\t/**\n\t * Builds the info object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @param {Object} config The config object for the key.\n\t * @param {*} initialValue The initial value of the key.\n\t * @protected\n\t */\n\tbuildKeyInfo_(name, config, initialValue) {\n\t\tthis.assertValidStateKeyName_(name);\n\n\t\tthis.stateInfo_[name] = {\n\t\t\tconfig: config || {},\n\t\t\tinitialValue: initialValue,\n\t\t\tstate: State.KeyStates.UNINITIALIZED\n\t\t};\n\t}\n\n\t/**\n\t * Builds the property definition object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tbuildKeyPropertyDef_(name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn this.getStateKeyValue_(name);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis.setStateKeyValue_(name, val);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Calls the requested function, running the appropriate code for when it's\n\t * passed as an actual function object or just the function's name.\n\t * @param {!Function|string} fn Function, or name of the function to run.\n\t * @param {!Array} An optional array of parameters to be passed to the\n\t *   function that will be called.\n\t * @return {*} The return value of the called function.\n\t * @protected\n\t */\n\tcallFunction_(fn, args) {\n\t\tif (core.isString(fn)) {\n\t\t\treturn this[fn].apply(this, args);\n\t\t} else if (core.isFunction(fn)) {\n\t\t\treturn fn.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the state key's setter, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be set.\n\t * @param {*} currentValue The current value.\n\t * @return {*} The final value to be set.\n\t * @protected\n\t */\n\tcallSetter_(name, value, currentValue) {\n\t\tvar info = this.stateInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.setter) {\n\t\t\tvalue = this.callFunction_(config.setter, [value, currentValue]);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Calls the state key's validator, if there is one. Emits console\n\t * warning if validator returns a string.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tcallValidator_(name, value) {\n\t\tvar info = this.stateInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.validator) {\n\t\t\tvar validatorReturn = this.callFunction_(config.validator, [value, name, this]);\n\n\t\t\tif (validatorReturn instanceof Error) {\n\t\t\t\tconsole.error(`Warning: ${validatorReturn}`);\n\t\t\t}\n\t\t\treturn validatorReturn;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the it's allowed to write on the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\tcanSetState(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn !info.config.writeOnce || !info.written;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.stateInfo_ = null;\n\t\tthis.scheduledBatchData_ = null;\n\t}\n\n\t/**\n\t * Emits the state change batch event.\n\t * @protected\n\t */\n\temitBatchEvent_() {\n\t\tif (!this.isDisposed()) {\n\t\t\tvar data = this.scheduledBatchData_;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t\tthis.emit('stateChanged', data);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the requested state key.\n\t * Note: this can and should be accomplished by accessing the value as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this[name];\n\t}\n\n\t/**\n\t * Returns an object that maps state keys to their values.\n\t * @param {Array<string>=} opt_names A list of names of the keys that should\n\t *   be returned. If none is given, the whole state will be returned.\n\t * @return {Object.<string, *>}\n\t */\n\tgetState(opt_names) {\n\t\tvar state = {};\n\t\tvar names = opt_names || this.getStateKeys();\n\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tstate[names[i]] = this[names[i]];\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets the config object for the requested state key.\n\t * @param {string} name The key's name.\n\t * @return {Object}\n\t * @protected\n\t */\n\tgetStateKeyConfig(name) {\n\t\treturn (this.stateInfo_[name] || {}).config;\n\t}\n\n\t/**\n\t * Returns an array with all state keys.\n\t * @return {Array.<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn Object.keys(this.stateInfo_);\n\t}\n\n\t/**\n\t * Gets the value of the specified state key. This is passed as that key's\n\t * getter to the `Object.defineProperty` call inside the `addKeyToState` method.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tgetStateKeyValue_(name) {\n\t\tthis.initStateKey_(name);\n\t\treturn this.stateInfo_[name].value;\n\t}\n\n\t/**\n\t * Checks if the value of the state key with the given name has already been\n\t * set. Note that this doesn't run the key's getter.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\thasBeenSet(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn info.state === State.KeyStates.INITIALIZED || info.initialValue;\n\t}\n\n\t/**\n\t * Checks if the given key is present in this instance's state.\n\t * @param {string} key\n\t * @return {boolean}\n\t */\n\thasStateKey(key) {\n\t\treturn !!this.stateInfo_[key];\n\t}\n\n\t/**\n\t * Informs of changes to a state key's value through an event. Won't trigger\n\t * the event if the value hasn't changed or if it's being initialized.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @protected\n\t */\n\tinformChange_(name, prevVal) {\n\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\tvar data = {\n\t\t\t\tkey: name,\n\t\t\t\tnewVal: this[name],\n\t\t\t\tprevVal: prevVal\n\t\t\t};\n\t\t\tthis.emit(name + 'Changed', data);\n\t\t\tthis.emit('stateKeyChanged', data);\n\t\t\tthis.scheduleBatchEvent_(data);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the specified state key, giving it a first value.\n\t * @param {string} name The name of the key.\n\t * @protected\n\t */\n\tinitStateKey_(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\tif (info.state !== State.KeyStates.UNINITIALIZED) {\n\t\t\treturn;\n\t\t}\n\n\t\tinfo.state = State.KeyStates.INITIALIZING;\n\t\tthis.setInitialValue_(name);\n\t\tif (!info.written) {\n\t\t\tinfo.state = State.KeyStates.INITIALIZING_DEFAULT;\n\t\t\tthis.setDefaultValue_(name);\n\t\t}\n\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t}\n\n\t/**\n\t * Merges an array of values for the STATE property into a single object.\n\t * @param {!Array} values The values to be merged.\n\t * @return {!Object} The merged value.\n\t * @static\n\t * @protected\n\t */\n\tstatic mergeState_(values) {\n\t\treturn object.mixin.apply(null, [{}].concat(values.reverse()));\n\t}\n\n\t/**\n\t * Merges the STATE static variable for the given constructor function.\n\t * @param  {!Function} ctor Constructor function.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t * @static\n\t */\n\tstatic mergeStateStatic(ctor) {\n\t\treturn core.mergeSuperClassesProperty(ctor, 'STATE', State.mergeState_);\n\t}\n\n\t/**\n\t * Merges the values of the `INVALID_KEYS` static for the whole hierarchy of\n\t * the current instance.\n\t * @protected\n\t */\n\tmergeInvalidKeys_() {\n\t\tcore.mergeSuperClassesProperty(this.constructor, 'INVALID_KEYS', function(values) {\n\t\t\treturn array.flatten(values).reduce(function(merged, val) {\n\t\t\t\tif (val) {\n\t\t\t\t\tmerged[val] = true;\n\t\t\t\t}\n\t\t\t\treturn merged;\n\t\t\t}, {});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the requested state key.\n\t * @param {string} name The name of the key.\n\t */\n\tremoveStateKey(name) {\n\t\tthis.stateInfo_[name] = null;\n\t\tdelete this[name];\n\t}\n\n\t/**\n\t * Schedules a state change batch event to be emitted asynchronously.\n\t * @param {!Object} changeData Information about a state key's update.\n\t * @protected\n\t */\n\tscheduleBatchEvent_(changeData) {\n\t\tif (!this.scheduledBatchData_) {\n\t\t\tasync.nextTick(this.emitBatchEvent_, this);\n\t\t\tthis.scheduledBatchData_ = {\n\t\t\t\tchanges: {}\n\t\t\t};\n\t\t}\n\n\t\tvar name = changeData.key;\n\t\tvar changes = this.scheduledBatchData_.changes;\n\t\tif (changes[name]) {\n\t\t\tchanges[name].newVal = changeData.newVal;\n\t\t} else {\n\t\t\tchanges[name] = changeData;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the requested state key.\n\t * Note: this can and should be accomplished by setting the state key as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @param {*} value\n\t * @return {*}\n\t */\n\tset(name, value) {\n\t\tif (this.hasStateKey(name)) {\n\t\t\tthis[name] = value;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tsetDefaultValue_(name) {\n\t\tvar config = this.stateInfo_[name].config;\n\n\t\tif (config.value !== undefined) {\n\t\t\tthis[name] = config.value;\n\t\t} else {\n\t\t\tthis[name] = this.callFunction_(config.valueFn);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the initial value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tsetInitialValue_(name) {\n\t\tvar info = this.stateInfo_[name];\n\t\tif (info.initialValue !== undefined) {\n\t\t\tthis[name] = info.initialValue;\n\t\t\tinfo.initialValue = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} values A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} opt_callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(values, opt_callback) {\n\t\tObject.keys(values).forEach(name => this.set(name, values[name]));\n\t\tif (opt_callback && this.scheduledBatchData_) {\n\t\t\tthis.once('stateChanged', opt_callback);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the specified state key. This is passed as that key's\n\t * setter to the `Object.defineProperty` call inside the `addKeyToState`\n\t * method.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The new value of the key.\n\t * @protected\n\t */\n\tsetStateKeyValue_(name, value) {\n\t\tif (!this.canSetState(name) || !this.validateKeyValue_(name, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar info = this.stateInfo_[name];\n\t\tif (info.initialValue === undefined && info.state === State.KeyStates.UNINITIALIZED) {\n\t\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t\t}\n\n\t\tvar prevVal = this[name];\n\t\tinfo.value = this.callSetter_(name, value, prevVal);\n\t\tinfo.written = true;\n\t\tthis.informChange_(name, prevVal);\n\t}\n\n\t/**\n\t * Checks if we should inform about a state update. Updates are ignored during\n\t * state initialization. Otherwise, updates to primitive values are only\n\t * informed when the new value is different from the previous one. Updates to\n\t * objects (which includes functions and arrays) are always informed outside\n\t * initialization though, since we can't be sure if all of the internal data\n\t * has stayed the same.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldInformChange_(name, prevVal) {\n\t\tvar info = this.stateInfo_[name];\n\t\treturn (info.state === State.KeyStates.INITIALIZED) &&\n\t\t\t(core.isObject(prevVal) || prevVal !== this[name]);\n\t}\n\n\t/**\n\t * Validates the state key's value, which includes calling the validator\n\t * defined in the key's configuration object, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tvalidateKeyValue_(name, value) {\n\t\tvar info = this.stateInfo_[name];\n\n\t\treturn info.state === State.KeyStates.INITIALIZING_DEFAULT ||\n\t\t\tthis.callValidator_(name, value);\n\t}\n}\n\n/**\n * A list with state key names that will automatically be rejected as invalid.\n * Subclasses can define their own invalid keys by setting this static on their\n * constructors, which will be merged together and handled automatically.\n * @type {!Array<string>}\n */\nState.INVALID_KEYS = ['state', 'stateKey'];\n\n/**\n * Constants that represent the states that an a state key can be in.\n * @type {!Object}\n */\nState.KeyStates = {\n\tUNINITIALIZED: 0,\n\tINITIALIZING: 1,\n\tINITIALIZING_DEFAULT: 2,\n\tINITIALIZED: 3\n};\n\nexport default State;\n"],"sourceRoot":"/source/"}