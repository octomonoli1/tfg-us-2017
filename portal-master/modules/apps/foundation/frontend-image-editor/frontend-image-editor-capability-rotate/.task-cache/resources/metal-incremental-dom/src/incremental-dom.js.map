{"version":3,"sources":["incremental-dom.js"],"names":[],"mappings":"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","file":"../../../node_modules/metal-incremental-dom/src/incremental-dom.js","sourcesContent":["/* jshint ignore:start */\n\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function (global, factory) {\n  (factory((global.IncrementalDOM = global.IncrementalDOM || {})));\n}(window, function (exports) { 'use strict';\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * A cached reference to the hasOwnProperty function.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * A constructor function that will create blank objects.\n   * @constructor\n   */\n  function Blank() {}\n\n  Blank.prototype = Object.create(null);\n\n  /**\n   * Used to prevent property collisions between our \"map\" and its prototype.\n   * @param {!Object<string, *>} map The map to check.\n   * @param {string} property The property to check.\n   * @return {boolean} Whether map has property.\n   */\n  var has = function (map, property) {\n    return hasOwnProperty.call(map, property);\n  };\n\n  /**\n   * Creates an map object without a prototype.\n   * @return {!Object}\n   */\n  var createMap = function () {\n    return new Blank();\n  };\n\n  /**\n   * The property name where we store Incremental DOM data.\n   */\n  var DATA_PROP = '__incrementalDOMData';\n\n  /**\n   * Keeps track of information needed to perform diffs for a given DOM node.\n   * @param {!string} nodeName\n   * @param {?string=} key\n   * @constructor\n   */\n  function NodeData(nodeName, key) {\n    /**\n     * The attributes and their values.\n     * @const {!Object<string, *>}\n     */\n    this.attrs = createMap();\n\n    /**\n     * An array of attribute name/value pairs, used for quickly diffing the\n     * incomming attributes to see if the DOM node's attributes need to be\n     * updated.\n     * @const {Array<*>}\n     */\n    this.attrsArr = [];\n\n    /**\n     * The incoming attributes for this Node, before they are updated.\n     * @const {!Object<string, *>}\n     */\n    this.newAttrs = createMap();\n\n    /**\n     * Whether or not the statics have been applied for the node yet.\n     * {boolean}\n     */\n    this.staticsApplied = false;\n\n    /**\n     * The key used to identify this node, used to preserve DOM nodes when they\n     * move within their parent.\n     * @const\n     */\n    this.key = key;\n\n    /**\n     * Keeps track of children within this node by their key.\n     * {!Object<string, !Element>}\n     */\n    this.keyMap = createMap();\n\n    /**\n     * Whether or not the keyMap is currently valid.\n     * @type {boolean}\n     */\n    this.keyMapValid = true;\n\n    /**\n     * Whether or the associated node is, or contains, a focused Element.\n     * @type {boolean}\n     */\n    this.focused = false;\n\n    /**\n     * The node name for this node.\n     * @const {string}\n     */\n    this.nodeName = nodeName;\n\n    /**\n     * @type {?string}\n     */\n    this.text = null;\n  }\n\n  /**\n   * Initializes a NodeData object for a Node.\n   *\n   * @param {Node} node The node to initialize data for.\n   * @param {string} nodeName The node name of node.\n   * @param {?string=} key The key that identifies the node.\n   * @return {!NodeData} The newly initialized data object\n   */\n  var initData = function (node, nodeName, key) {\n    var data = new NodeData(nodeName, key);\n    node[DATA_PROP] = data;\n    return data;\n  };\n\n  /**\n   * Retrieves the NodeData object for a Node, creating it if necessary.\n   *\n   * @param {?Node} node The Node to retrieve the data for.\n   * @return {!NodeData} The NodeData for this Node.\n   */\n  var getData = function (node) {\n    importNode(node);\n    return node[DATA_PROP];\n  };\n\n  /**\n   * Imports node and its subtree, initializing caches.\n   *\n   * @param {?Node} node The Node to import.\n   */\n  var importNode = function (node) {\n    if (node[DATA_PROP]) {\n      return;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    var isElement = node instanceof Element;\n    var key = isElement ? node.getAttribute('key') : null;\n    var data = initData(node, nodeName, key);\n\n    if (key) {\n      getData(node.parentNode).keyMap[key] = node;\n    }\n\n    if (isElement) {\n      var attributes = node.attributes;\n      var attrs = data.attrs;\n      var newAttrs = data.newAttrs;\n      var attrsArr = data.attrsArr;\n\n      for (var i = 0; i < attributes.length; i += 1) {\n        var attr = attributes[i];\n        var name = attr.name;\n        var value = attr.value;\n\n        attrs[name] = value;\n        newAttrs[name] = undefined;\n        attrsArr.push(name);\n        attrsArr.push(value);\n      }\n    }\n\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      importNode(child);\n    }\n  };\n\n  /**\n   * Gets the namespace to create an element (of a given tag) in.\n   * @param {string} tag The tag to get the namespace for.\n   * @param {?Node} parent\n   * @return {?string} The namespace to create the tag in.\n   */\n  var getNamespaceForTag = function (tag, parent) {\n    if (tag === 'svg') {\n      return 'http://www.w3.org/2000/svg';\n    }\n\n    if (getData(parent).nodeName === 'foreignObject') {\n      return null;\n    }\n\n    return parent.namespaceURI;\n  };\n\n  /**\n   * Creates an Element.\n   * @param {Document} doc The document with which to create the Element.\n   * @param {?Node} parent\n   * @param {string} tag The tag for the Element.\n   * @param {?string=} key A key to identify the Element.\n   * @return {!Element}\n   */\n  var createElement = function (doc, parent, tag, key) {\n    var namespace = getNamespaceForTag(tag, parent);\n    var el = undefined;\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, tag);\n    } else {\n      el = doc.createElement(tag);\n    }\n\n    initData(el, tag, key);\n\n    return el;\n  };\n\n  /**\n   * Creates a Text Node.\n   * @param {Document} doc The document with which to create the Element.\n   * @return {!Text}\n   */\n  var createText = function (doc) {\n    var node = doc.createTextNode('');\n    initData(node, '#text', null);\n    return node;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /** @const */\n  var notifications = {\n    /**\n     * Called after patch has compleated with any Nodes that have been created\n     * and added to the DOM.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesCreated: null,\n\n    /**\n     * Called after patch has compleated with any Nodes that have been removed\n     * from the DOM.\n     * Note it's an applications responsibility to handle any childNodes.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesDeleted: null\n  };\n\n  /**\n   * Keeps track of the state of a patch.\n   * @constructor\n   */\n  function Context() {\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.created = notifications.nodesCreated && [];\n\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.deleted = notifications.nodesDeleted && [];\n  }\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markCreated = function (node) {\n    if (this.created) {\n      this.created.push(node);\n    }\n  };\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markDeleted = function (node) {\n    if (this.deleted) {\n      this.deleted.push(node);\n    }\n  };\n\n  /**\n   * Notifies about nodes that were created during the patch opearation.\n   */\n  Context.prototype.notifyChanges = function () {\n    if (this.created && this.created.length > 0) {\n      notifications.nodesCreated(this.created);\n    }\n\n    if (this.deleted && this.deleted.length > 0) {\n      notifications.nodesDeleted(this.deleted);\n    }\n  };\n\n  /**\n   * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * @param {!Node} node\n   * @return {boolean} True if the node the root of a document, false otherwise.\n   */\n  var isDocumentRoot = function (node) {\n    // For ShadowRoots, check if they are a DocumentFragment instead of if they\n    // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n    // not supported.\n    return node instanceof Document || node instanceof DocumentFragment;\n  };\n\n  /**\n   * @param {!Node} node The node to start at, inclusive.\n   * @param {?Node} root The root ancestor to get until, exclusive.\n   * @return {!Array<!Node>} The ancestry of DOM nodes.\n   */\n  var getAncestry = function (node, root) {\n    var ancestry = [];\n    var cur = node;\n\n    while (cur !== root) {\n      ancestry.push(cur);\n      cur = cur.parentNode;\n    }\n\n    return ancestry;\n  };\n\n  /**\n   * @param {!Node} node\n   * @return {!Node} The root node of the DOM tree that contains node.\n   */\n  var getRoot = function (node) {\n    var cur = node;\n    var prev = cur;\n\n    while (cur) {\n      prev = cur;\n      cur = cur.parentNode;\n    }\n\n    return prev;\n  };\n\n  /**\n   * @param {!Node} node The node to get the activeElement for.\n   * @return {?Element} The activeElement in the Document or ShadowRoot\n   *     corresponding to node, if present.\n   */\n  var getActiveElement = function (node) {\n    var root = getRoot(node);\n    return isDocumentRoot(root) ? root.activeElement : null;\n  };\n\n  /**\n   * Gets the path of nodes that contain the focused node in the same document as\n   * a reference node, up until the root.\n   * @param {!Node} node The reference node to get the activeElement for.\n   * @param {?Node} root The root to get the focused path until.\n   * @return {!Array<Node>}\n   */\n  var getFocusedPath = function (node, root) {\n    var activeElement = getActiveElement(node);\n\n    if (!activeElement || !node.contains(activeElement)) {\n      return [];\n    }\n\n    return getAncestry(activeElement, root);\n  };\n\n  /**\n   * Like insertBefore, but instead instead of moving the desired node, instead\n   * moves all the other nodes after.\n   * @param {?Node} parentNode\n   * @param {!Node} node\n   * @param {?Node} referenceNode\n   */\n  var moveBefore = function (parentNode, node, referenceNode) {\n    var insertReferenceNode = node.nextSibling;\n    var cur = referenceNode;\n\n    while (cur !== node) {\n      var next = cur.nextSibling;\n      parentNode.insertBefore(cur, insertReferenceNode);\n      cur = next;\n    }\n  };\n\n  /** @type {?Context} */\n  var context = null;\n\n  /** @type {?Node} */\n  var currentNode = null;\n\n  /** @type {?Node} */\n  var currentParent = null;\n\n  /** @type {?Document} */\n  var doc = null;\n\n  /**\n   * @param {!Array<Node>} focusPath The nodes to mark.\n   * @param {boolean} focused Whether or not they are focused.\n   */\n  var markFocused = function (focusPath, focused) {\n    for (var i = 0; i < focusPath.length; i += 1) {\n      getData(focusPath[i]).focused = focused;\n    }\n  };\n\n  /**\n   * Returns a patcher function that sets up and restores a patch context,\n   * running the run function with the provided data.\n   * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n   * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n   * @template T\n   */\n  var patchFactory = function (run) {\n    /**\n     * TODO(moz): These annotations won't be necessary once we switch to Closure\n     * Compiler's new type inference. Remove these once the switch is done.\n     *\n     * @param {(!Element|!DocumentFragment)} node\n     * @param {!function(T)} fn\n     * @param {T=} data\n     * @return {?Node} node\n     * @template T\n     */\n    var f = function (node, fn, data) {\n      var prevContext = context;\n      var prevDoc = doc;\n      var prevCurrentNode = currentNode;\n      var prevCurrentParent = currentParent;\n      var previousInAttributes = false;\n      var previousInSkip = false;\n\n      context = new Context();\n      doc = node.ownerDocument;\n      currentParent = node.parentNode;\n\n      if ('production' !== 'production') {}\n\n      var focusPath = getFocusedPath(node, currentParent);\n      markFocused(focusPath, true);\n      var retVal = run(node, fn, data);\n      markFocused(focusPath, false);\n\n      if ('production' !== 'production') {}\n\n      context.notifyChanges();\n\n      context = prevContext;\n      doc = prevDoc;\n      currentNode = prevCurrentNode;\n      currentParent = prevCurrentParent;\n\n      return retVal;\n    };\n    return f;\n  };\n\n  /**\n   * Patches the document starting at node with the provided function. This\n   * function may be called during an existing patch operation.\n   * @param {!Element|!DocumentFragment} node The Element or Document\n   *     to patch.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @return {!Node} The patched node.\n   * @template T\n   */\n  var patchInner = patchFactory(function (node, fn, data) {\n    currentNode = node;\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if ('production' !== 'production') {}\n\n    return node;\n  });\n\n  /**\n   * Patches an Element with the the provided function. Exactly one top level\n   * element call should be made corresponding to `node`.\n   * @param {!Element} node The Element where the patch should start.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM. This should have at most one top level\n   *     element call.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @return {?Node} The node if it was updated, its replacedment or null if it\n   *     was removed.\n   * @template T\n   */\n  var patchOuter = patchFactory(function (node, fn, data) {\n    var startNode = /** @type {!Element} */{ nextSibling: node };\n    var expectedNextNode = null;\n    var expectedPrevNode = null;\n\n    if ('production' !== 'production') {}\n\n    currentNode = startNode;\n    fn(data);\n\n    if ('production' !== 'production') {}\n\n    if (node !== currentNode) {\n      removeChild(currentParent, node, getData(currentParent).keyMap);\n    }\n\n    return startNode === currentNode ? null : currentNode;\n  });\n\n  /**\n   * Checks whether or not the current node matches the specified nodeName and\n   * key.\n   *\n   * @param {!Node} matchNode A node to match the data to.\n   * @param {?string} nodeName The nodeName for this node.\n   * @param {?string=} key An optional key that identifies a node.\n   * @return {boolean} True if the node matches, false otherwise.\n   */\n  var matches = function (matchNode, nodeName, key) {\n    var data = getData(matchNode);\n\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return nodeName === data.nodeName && key == data.key;\n  };\n\n  /**\n   * Aligns the virtual Element definition with the actual DOM, moving the\n   * corresponding DOM node to the correct location or creating it if necessary.\n   * @param {string} nodeName For an Element, this should be a valid tag string.\n   *     For a Text, this should be #text.\n   * @param {?string=} key The key used to identify this element.\n   */\n  var alignWithDOM = function (nodeName, key) {\n    if (currentNode && matches(currentNode, nodeName, key)) {\n      return;\n    }\n\n    var parentData = getData(currentParent);\n    var currentNodeData = currentNode && getData(currentNode);\n    var keyMap = parentData.keyMap;\n    var node = undefined;\n\n    // Check to see if the node has moved within the parent.\n    if (key) {\n      var keyNode = keyMap[key];\n      if (keyNode) {\n        if (matches(keyNode, nodeName, key)) {\n          node = keyNode;\n        } else if (keyNode === currentNode) {\n          context.markDeleted(keyNode);\n        } else {\n          removeChild(currentParent, keyNode, keyMap);\n        }\n      }\n    }\n\n    // Create the node if it doesn't exist.\n    if (!node) {\n      if (nodeName === '#text') {\n        node = createText(doc);\n      } else {\n        node = createElement(doc, currentParent, nodeName, key);\n      }\n\n      if (key) {\n        keyMap[key] = node;\n      }\n\n      context.markCreated(node);\n    }\n\n    // Re-order the node into the right position, preserving focus if either\n    // node or currentNode are focused by making sure that they are not detached\n    // from the DOM.\n    if (getData(node).focused) {\n      // Move everything else before the node.\n      moveBefore(currentParent, node, currentNode);\n    } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n      // Remove the currentNode, which can always be added back since we hold a\n      // reference through the keyMap. This prevents a large number of moves when\n      // a keyed item is removed or moved backwards in the DOM.\n      currentParent.replaceChild(node, currentNode);\n      parentData.keyMapValid = false;\n    } else {\n      currentParent.insertBefore(node, currentNode);\n    }\n\n    currentNode = node;\n  };\n\n  /**\n   * @param {?Node} node\n   * @param {?Node} child\n   * @param {?Object<string, !Element>} keyMap\n   */\n  var removeChild = function (node, child, keyMap) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    var key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n  };\n\n  /**\n   * Clears out any unvisited Nodes, as the corresponding virtual element\n   * functions were never called for them.\n   */\n  var clearUnvisitedDOM = function () {\n    var node = currentParent;\n    var data = getData(node);\n    var keyMap = data.keyMap;\n    var keyMapValid = data.keyMapValid;\n    var child = node.lastChild;\n    var key = undefined;\n\n    if (child === currentNode && keyMapValid) {\n      return;\n    }\n\n    while (child !== currentNode) {\n      removeChild(node, child, keyMap);\n      child = node.lastChild;\n    }\n\n    // Clean the keyMap, removing any unusued keys.\n    if (!keyMapValid) {\n      for (key in keyMap) {\n        child = keyMap[key];\n        if (child.parentNode !== node) {\n          context.markDeleted(child);\n          delete keyMap[key];\n        }\n      }\n\n      data.keyMapValid = true;\n    }\n  };\n\n  /**\n   * Changes to the first child of the current node.\n   */\n  var enterNode = function () {\n    currentParent = currentNode;\n    currentNode = null;\n  };\n\n  /**\n   * @return {?Node} The next Node to be patched.\n   */\n  var getNextNode = function () {\n    if (currentNode) {\n      return currentNode.nextSibling;\n    } else {\n      return currentParent.firstChild;\n    }\n  };\n\n  /**\n   * Changes to the next sibling of the current node.\n   */\n  var nextNode = function () {\n    currentNode = getNextNode();\n  };\n\n  /**\n   * Changes to the parent of the current node, removing any unvisited children.\n   */\n  var exitNode = function () {\n    clearUnvisitedDOM();\n\n    currentNode = currentParent;\n    currentParent = currentParent.parentNode;\n  };\n\n  /**\n   * Makes sure that the current node is an Element with a matching tagName and\n   * key.\n   *\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @return {!Element} The corresponding Element.\n   */\n  var coreElementOpen = function (tag, key) {\n    nextNode();\n    alignWithDOM(tag, key);\n    enterNode();\n    return (/** @type {!Element} */currentParent\n    );\n  };\n\n  /**\n   * Closes the currently open Element, removing any unvisited children if\n   * necessary.\n   *\n   * @return {!Element} The corresponding Element.\n   */\n  var coreElementClose = function () {\n    if ('production' !== 'production') {}\n\n    exitNode();\n    return (/** @type {!Element} */currentNode\n    );\n  };\n\n  /**\n   * Makes sure the current node is a Text node and creates a Text node if it is\n   * not.\n   *\n   * @return {!Text} The corresponding Text Node.\n   */\n  var coreText = function () {\n    nextNode();\n    alignWithDOM('#text', null);\n    return (/** @type {!Text} */currentNode\n    );\n  };\n\n  /**\n   * Gets the current Element being patched.\n   * @return {!Element}\n   */\n  var currentElement = function () {\n    if ('production' !== 'production') {}\n    return (/** @type {!Element} */currentParent\n    );\n  };\n\n  /**\n   * @return {Node} The Node that will be evaluated for the next instruction.\n   */\n  var currentPointer = function () {\n    if ('production' !== 'production') {}\n    return getNextNode();\n  };\n\n  /**\n   * Skips the children in a subtree, allowing an Element to be closed without\n   * clearing out the children.\n   */\n  var skip = function () {\n    if ('production' !== 'production') {}\n    currentNode = currentParent.lastChild;\n  };\n\n  /**\n   * Skips the next Node to be patched, moving the pointer forward to the next\n   * sibling of the current pointer.\n   */\n  var skipNode = nextNode;\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /** @const */\n  var symbols = {\n    default: '__default'\n  };\n\n  /**\n   * @param {string} name\n   * @return {string|undefined} The namespace to use for the attribute.\n   */\n  var getNamespace = function (name) {\n    if (name.lastIndexOf('xml:', 0) === 0) {\n      return 'http://www.w3.org/XML/1998/namespace';\n    }\n\n    if (name.lastIndexOf('xlink:', 0) === 0) {\n      return 'http://www.w3.org/1999/xlink';\n    }\n  };\n\n  /**\n   * Applies an attribute or property to a given Element. If the value is null\n   * or undefined, it is removed from the Element. Otherwise, the value is set\n   * as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {?(boolean|number|string)=} value The attribute's value.\n   */\n  var applyAttr = function (el, name, value) {\n    if (value == null) {\n      el.removeAttribute(name);\n    } else {\n      var attrNS = getNamespace(name);\n      if (attrNS) {\n        el.setAttributeNS(attrNS, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    }\n  };\n\n  /**\n   * Applies a property to a given Element.\n   * @param {!Element} el\n   * @param {string} name The property's name.\n   * @param {*} value The property's value.\n   */\n  var applyProp = function (el, name, value) {\n    el[name] = value;\n  };\n\n  /**\n   * Applies a value to a style declaration. Supports CSS custom properties by\n   * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n   * @param {CSSStyleDeclaration} style\n   * @param {!string} prop\n   * @param {*} value\n   */\n  var setStyleValue = function (style, prop, value) {\n    if (prop.indexOf('-') >= 0) {\n      style.setProperty(prop, /** @type {string} */value);\n    } else {\n      style[prop] = value;\n    }\n  };\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} style The style to set. Either a string of css or an object\n   *     containing property-value pairs.\n   */\n  var applyStyle = function (el, name, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n      var elStyle = el.style;\n      var obj = /** @type {!Object<string,string>} */style;\n\n      for (var prop in obj) {\n        if (has(obj, prop)) {\n          setStyleValue(elStyle, prop, obj[prop]);\n        }\n      }\n    }\n  };\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is an object or\n   *     function it is set on the Element, otherwise, it is set as an HTML\n   *     attribute.\n   */\n  var applyAttributeTyped = function (el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      applyProp(el, name, value);\n    } else {\n      applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n    }\n  };\n\n  /**\n   * Calls the appropriate attribute mutator for this attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value.\n   */\n  var updateAttribute = function (el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    var mutator = attributes[name] || attributes[symbols.default];\n    mutator(el, name, value);\n\n    attrs[name] = value;\n  };\n\n  /**\n   * A publicly mutable object to provide custom mutators for attributes.\n   * @const {!Object<string, function(!Element, string, *)>}\n   */\n  var attributes = createMap();\n\n  // Special generic mutator that's called for any attribute that does not\n  // have a specific mutator.\n  attributes[symbols.default] = applyAttributeTyped;\n\n  attributes['style'] = applyStyle;\n\n  /**\n   * The offset in the virtual element declaration where the attributes are\n   * specified.\n   * @const\n   */\n  var ATTRIBUTES_OFFSET = 3;\n\n  /**\n   * Builds an array of arguments for use with elementOpenStart, attr and\n   * elementOpenEnd.\n   * @const {Array<*>}\n   */\n  var argsBuilder = [];\n\n  /**\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementOpen = function (tag, key, statics, var_args) {\n    if ('production' !== 'production') {}\n\n    var node = coreElementOpen(tag, key);\n    var data = getData(node);\n\n    if (!data.staticsApplied) {\n      if (statics) {\n        for (var _i = 0; _i < statics.length; _i += 2) {\n          var name = /** @type {string} */statics[_i];\n          var value = statics[_i + 1];\n          updateAttribute(node, name, value);\n        }\n      }\n      // Down the road, we may want to keep track of the statics array to use it\n      // as an additional signal about whether a node matches or not. For now,\n      // just use a marker so that we do not reapply statics.\n      data.staticsApplied = true;\n    }\n\n    /*\n     * Checks to see if one or more attributes have changed for a given Element.\n     * When no attributes have changed, this is much faster than checking each\n     * individual argument. When attributes have changed, the overhead of this is\n     * minimal.\n     */\n    var attrsArr = data.attrsArr;\n    var newAttrs = data.newAttrs;\n    var isNew = !attrsArr.length;\n    var i = ATTRIBUTES_OFFSET;\n    var j = 0;\n\n    for (; i < arguments.length; i += 2, j += 2) {\n      var _attr = arguments[i];\n      if (isNew) {\n        attrsArr[j] = _attr;\n        newAttrs[_attr] = undefined;\n      } else if (attrsArr[j] !== _attr) {\n        break;\n      }\n\n      var value = arguments[i + 1];\n      if (isNew || attrsArr[j + 1] !== value) {\n        attrsArr[j + 1] = value;\n        updateAttribute(node, _attr, value);\n      }\n    }\n\n    if (i < arguments.length || j < attrsArr.length) {\n      for (; i < arguments.length; i += 1, j += 1) {\n        attrsArr[j] = arguments[i];\n      }\n\n      if (j < attrsArr.length) {\n        attrsArr.length = j;\n      }\n\n      /*\n       * Actually perform the attribute update.\n       */\n      for (i = 0; i < attrsArr.length; i += 2) {\n        var name = /** @type {string} */attrsArr[i];\n        var value = attrsArr[i + 1];\n        newAttrs[name] = value;\n      }\n\n      for (var _attr2 in newAttrs) {\n        updateAttribute(node, _attr2, newAttrs[_attr2]);\n        newAttrs[_attr2] = undefined;\n      }\n    }\n\n    return node;\n  };\n\n  /**\n   * Declares a virtual Element at the current location in the document. This\n   * corresponds to an opening tag and a elementClose tag is required. This is\n   * like elementOpen, but the attributes are defined using the attr function\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\n   * to attr, then a call to elementOpenEnd.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   */\n  var elementOpenStart = function (tag, key, statics) {\n    if ('production' !== 'production') {}\n\n    argsBuilder[0] = tag;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n  };\n\n  /***\n   * Defines a virtual attribute at this point of the DOM. This is only valid\n   * when called between elementOpenStart and elementOpenEnd.\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  var attr = function (name, value) {\n    if ('production' !== 'production') {}\n\n    argsBuilder.push(name);\n    argsBuilder.push(value);\n  };\n\n  /**\n   * Closes an open tag started with elementOpenStart.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementOpenEnd = function () {\n    if ('production' !== 'production') {}\n\n    var node = elementOpen.apply(null, argsBuilder);\n    argsBuilder.length = 0;\n    return node;\n  };\n\n  /**\n   * Closes an open virtual Element.\n   *\n   * @param {string} tag The element's tag.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementClose = function (tag) {\n    if ('production' !== 'production') {}\n\n    var node = coreElementClose();\n\n    if ('production' !== 'production') {}\n\n    return node;\n  };\n\n  /**\n   * Declares a virtual Element at the current location in the document that has\n   * no children.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementVoid = function (tag, key, statics, var_args) {\n    elementOpen.apply(null, arguments);\n    return elementClose(tag);\n  };\n\n  /**\n   * Declares a virtual Text at this point in the document.\n   *\n   * @param {string|number|boolean} value The value of the Text.\n   * @param {...(function((string|number|boolean)):string)} var_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   * @return {!Text} The corresponding text node.\n   */\n  var text = function (value, var_args) {\n    if ('production' !== 'production') {}\n\n    var node = coreText();\n    var data = getData(node);\n\n    if (data.text !== value) {\n      data.text = /** @type {string} */value;\n\n      var formatted = value;\n      for (var i = 1; i < arguments.length; i += 1) {\n        /*\n         * Call the formatter function directly to prevent leaking arguments.\n         * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n         */\n        var fn = arguments[i];\n        formatted = fn(formatted);\n      }\n\n      node.data = formatted;\n    }\n\n    return node;\n  };\n\n  exports.patch = patchInner;\n  exports.patchInner = patchInner;\n  exports.patchOuter = patchOuter;\n  exports.currentElement = currentElement;\n  exports.currentPointer = currentPointer;\n  exports.skip = skip;\n  exports.skipNode = skipNode;\n  exports.elementVoid = elementVoid;\n  exports.elementOpenStart = elementOpenStart;\n  exports.elementOpenEnd = elementOpenEnd;\n  exports.elementOpen = elementOpen;\n  exports.elementClose = elementClose;\n  exports.text = text;\n  exports.attr = attr;\n  exports.symbols = symbols;\n  exports.attributes = attributes;\n  exports.applyAttr = applyAttr;\n  exports.applyProp = applyProp;\n  exports.notifications = notifications;\n  exports.importNode = importNode;\n\n}));\n\n/* jshint ignore:end */\n"],"sourceRoot":"/source/"}