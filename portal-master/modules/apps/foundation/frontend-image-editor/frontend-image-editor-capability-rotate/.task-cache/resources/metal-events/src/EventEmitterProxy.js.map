{"version":3,"sources":["EventEmitterProxy.js"],"names":[],"mappings":"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","file":"../../../node_modules/metal-events/src/EventEmitterProxy.js","sourcesContent":["'use strict';\n\nimport { array, Disposable } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist || {};\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * A list of events that are pending to be listened by an actual origin\n\t\t * emitter. Events are stored here when the origin doesn't exist, so they\n\t\t * can be set on a new origin when one is set.\n\t\t * @type {!Array}\n\t\t * @protected\n\t\t */\n\t\tthis.pendingEvents_ = [];\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object<string, !EventHandle>}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = {};\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the given listener for the given event.\n\t * @param {string} event\n\t * @param {!function()} listener\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListener_(event, listener) {\n\t\treturn this.originEmitter_.on(event, listener);\n\t}\n\n\t/**\n\t * Adds the proxy listener for the given event.\n\t * @param {string} event\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListenerForEvent_(event) {\n\t\treturn this.addListener_(event, this.emitOnTarget_.bind(this, event));\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.removeListeners_();\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Emits the specified event type on the target emitter.\n\t * @param {string} eventType\n\t * @protected\n\t */\n\temitOnTarget_(eventType) {\n\t\tvar args = [eventType].concat(array.slice(arguments, 1));\n\t\tthis.targetEmitter_.emit.apply(this.targetEmitter_, args);\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent(event) {\n\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\tthis.tryToAddListener_(event);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the proxy listener for all events.\n\t * @protected\n\t */\n\tremoveListeners_() {\n\t\tvar events = Object.keys(this.proxiedEvents_);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t}\n\t\tthis.proxiedEvents_ = {};\n\t\tthis.pendingEvents_ = [];\n\t}\n\n\t/**\n\t * Changes the origin emitter. This automatically detaches any events that\n\t * were already being proxied from the previous emitter, and starts proxying\n\t * them on the new emitter instead.\n\t * @param {!EventEmitter} originEmitter\n\t */\n\tsetOriginEmitter(originEmitter) {\n\t\tvar events = this.originEmitter_?\n\t\t\tObject.keys(this.proxiedEvents_) :\n\t\t\tthis.pendingEvents_;\n\t\tthis.removeListeners_();\n\t\tthis.originEmitter_ = originEmitter;\n\t\tevents.forEach(event => this.proxyEvent(event));\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.on('newListener', this.proxyEvent.bind(this));\n\t}\n\n\t/**\n\t * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n\t * the pending listener so it can be used on a future origin emitter.\n\t * @param {string} event\n\t * @protected\n\t */\n\ttryToAddListener_(event) {\n\t\tif (this.originEmitter_) {\n\t\t\tthis.proxiedEvents_[event] = this.addListenerForEvent_(event);\n\t\t} else {\n\t\t\tthis.pendingEvents_.push(event);\n\t\t}\n\t}\n}\n\nexport default EventEmitterProxy;\n"],"sourceRoot":"/source/"}