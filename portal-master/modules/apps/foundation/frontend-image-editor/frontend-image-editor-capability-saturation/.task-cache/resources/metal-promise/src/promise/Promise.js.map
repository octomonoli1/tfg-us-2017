{"version":3,"sources":["Promise.js"],"names":[],"mappings":"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","file":"../../../node_modules/metal-promise/src/promise/Promise.js","sourcesContent":["/*!\n * Promises polyfill from Google's Closure Library.\n *\n *      Copyright 2013 The Closure Library Authors. All Rights Reserved.\n *\n * NOTE(eduardo): Promise support is not ready on all supported browsers,\n * therefore core.js is temporarily using Google's promises as polyfill. It\n * supports cancellable promises and has clean and fast implementation.\n */\n\n'use strict';\n\nimport { core } from 'metal';\nimport { async } from 'metal';\n\n/**\n * Provides a more strict interface for Thenables in terms of\n * http://promisesaplus.com for interop with {@see CancellablePromise}.\n *\n * @interface\n * @extends {IThenable.<TYPE>}\n * @template TYPE\n */\nvar Thenable = function() {};\n\n/**\n * Adds callbacks that will operate on the result of the Thenable, returning a\n * new child Promise.\n *\n * If the Thenable is fulfilled, the {@code onFulfilled} callback will be\n * invoked with the fulfillment value as argument, and the child Promise will\n * be fulfilled with the return value of the callback. If the callback throws\n * an exception, the child Promise will be rejected with the thrown value\n * instead.\n *\n * If the Thenable is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value of the callback or thrown value.\n *\n * @param {?(function(this:THIS, TYPE):\n *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fullfilled.\n * @param {?(function(*): *)=} opt_onRejected A function that will be invoked\n *     with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the\n *     result of the fulfillment or rejection callback.\n * @template RESULT,THIS\n */\nThenable.prototype.then = function() {};\n\n\n/**\n * An expando property to indicate that an object implements\n * {@code Thenable}.\n *\n * {@see addImplementation}.\n *\n * @const\n */\nThenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';\n\n\n/**\n * Marks a given class (constructor) as an implementation of Thenable, so\n * that we can query that fact at runtime. The class must have already\n * implemented the interface.\n * Exports a 'then' method on the constructor prototype, so that the objects\n * also implement the extern {@see Thenable} interface for interop with\n * other Promise implementations.\n * @param {function(new:Thenable,...[?])} ctor The class constructor. The\n *     corresponding class must have already implemented the interface.\n */\nThenable.addImplementation = function(ctor) {\n  ctor.prototype.then = ctor.prototype.then;\n  ctor.prototype.$goog_Thenable = true;\n};\n\n\n/**\n * @param {*} object\n * @return {boolean} Whether a given instance implements {@code Thenable}.\n *     The class/superclass of the instance must call {@code addImplementation}.\n */\nThenable.isImplementedBy = function(object) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object.$goog_Thenable;\n  } catch (e) {\n    // Property access seems to be forbidden.\n    return false;\n  }\n};\n\n\n/**\n * Like bind(), except that a 'this object' is not required. Useful when the\n * target function is already bound.\n *\n * Usage:\n * var g = partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n */\nvar partial = function(fn) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Clone the array (with slice()) and append additional arguments\n    // to the existing arguments.\n    var newArgs = args.slice();\n    newArgs.push.apply(newArgs, arguments);\n    return fn.apply(this, newArgs);\n  };\n};\n\n/**\n * Promises provide a result that may be resolved asynchronously. A Promise may\n * be resolved by being fulfilled or rejected with a value, which will be known\n * as the fulfillment value or the rejection reason. Whether fulfilled or\n * rejected, the Promise result is immutable once it is set.\n *\n * Promises may represent results of any type, including undefined. Rejection\n * reasons are typically Errors, but may also be of any type. Closure Promises\n * allow for optional type annotations that enforce that fulfillment values are\n * of the appropriate types at compile time.\n *\n * The result of a Promise is accessible by calling {@code then} and registering\n * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise\n * resolves, the relevant callbacks are invoked with the fulfillment value or\n * rejection reason as argument. Callbacks are always invoked in the order they\n * were registered, even when additional {@code then} calls are made from inside\n * another callback. A callback is always run asynchronously sometime after the\n * scope containing the registering {@code then} invocation has returned.\n *\n * If a Promise is resolved with another Promise, the first Promise will block\n * until the second is resolved, and then assumes the same result as the second\n * Promise. This allows Promises to depend on the results of other Promises,\n * linking together multiple asynchronous operations.\n *\n * This implementation is compatible with the Promises/A+ specification and\n * passes that specification's conformance test suite. A Closure Promise may be\n * resolved with a Promise instance (or sufficiently compatible Promise-like\n * object) created by other Promise implementations. From the specification,\n * Promise-like objects are known as \"Thenables\".\n *\n * @see http://promisesaplus.com/\n *\n * @param {function(\n *             this:RESOLVER_CONTEXT,\n *             function((TYPE|IThenable.<TYPE>|Thenable)),\n *             function(*)): void} resolver\n *     Initialization function that is invoked immediately with {@code resolve}\n *     and {@code reject} functions as arguments. The Promise is resolved or\n *     rejected with the first argument passed to either function.\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\n *     resolver function. If unspecified, the resolver function will be executed\n *     in the default scope.\n * @constructor\n * @struct\n * @final\n * @implements {Thenable.<TYPE>}\n * @template TYPE,RESOLVER_CONTEXT\n */\nvar CancellablePromise = function(resolver, opt_context) {\n  /**\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\n   * BLOCKED.\n   * @private {CancellablePromise.State_}\n   */\n  this.state_ = CancellablePromise.State_.PENDING;\n\n  /**\n   * The resolved result of the Promise. Immutable once set with either a\n   * fulfillment value or rejection reason.\n   * @private {*}\n   */\n  this.result_ = undefined;\n\n  /**\n   * For Promises created by calling {@code then()}, the originating parent.\n   * @private {CancellablePromise}\n   */\n  this.parent_ = null;\n\n  /**\n   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to\n   * this Promise by calls to {@code then()}.\n   * @private {Array.<CancellablePromise.CallbackEntry_>}\n   */\n  this.callbackEntries_ = null;\n\n  /**\n   * Whether the Promise is in the queue of Promises to execute.\n   * @private {boolean}\n   */\n  this.executing_ = false;\n\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    /**\n     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\n     * cleared only if an {@code onRejected} callback is invoked for the\n     * Promise (or one of its descendants) before the delay is exceeded.\n     *\n     * If the rejection is not handled before the timeout completes, the\n     * rejection reason is passed to the unhandled rejection handler.\n     * @private {number}\n     */\n    this.unhandledRejectionId_ = 0;\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    /**\n     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a\n     * boolean that is set if the Promise is rejected, and reset to false if an\n     * {@code onRejected} callback is invoked for the Promise (or one of its\n     * descendants). If the rejection is not handled before the next timestep,\n     * the rejection reason is passed to the unhandled rejection handler.\n     * @private {boolean}\n     */\n    this.hadUnhandledRejection_ = false;\n  }\n\n  try {\n    var self = this;\n    resolver.call(\n      opt_context, function(value) {\n        self.resolve_(CancellablePromise.State_.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(CancellablePromise.State_.REJECTED, reason);\n      });\n  } catch (e) {\n    this.resolve_(CancellablePromise.State_.REJECTED, e);\n  }\n};\n\n/**\n * The delay in milliseconds before a rejected Promise's reason is passed to\n * the rejection handler. By default, the rejection handler rethrows the\n * rejection reason so that it appears in the developer console or\n * {@code window.onerror} handler.\n * Rejections are rethrown as quickly as possible by default. A negative value\n * disables rejection handling entirely.\n * @type {number}\n */\nCancellablePromise.UNHANDLED_REJECTION_DELAY = 0;\n\n\n/**\n * The possible internal states for a Promise. These states are not directly\n * observable to external callers.\n * @enum {number}\n * @private\n */\nCancellablePromise.State_ = {\n  /** The Promise is waiting for resolution. */\n  PENDING: 0,\n\n  /** The Promise is blocked waiting for the result of another Thenable. */\n  BLOCKED: 1,\n\n  /** The Promise has been resolved with a fulfillment value. */\n  FULFILLED: 2,\n\n  /** The Promise has been resolved with a rejection reason. */\n  REJECTED: 3\n};\n\n\n/**\n * Typedef for entries in the callback chain. Each call to {@code then},\n * {@code thenCatch}, or {@code thenAlways} creates an entry containing the\n * functions that may be invoked once the Promise is resolved.\n *\n * @typedef {{\n *   child: CancellablePromise,\n *   onFulfilled: function(*),\n *   onRejected: function(*)\n * }}\n * @private\n */\nCancellablePromise.CallbackEntry_ = null;\n\n\n/**\n * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value\n * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved\n *     with the given value.\n * @template TYPE\n */\nCancellablePromise.resolve = function(opt_value) {\n  return new CancellablePromise(function(resolve) {\n      resolve(opt_value);\n    });\n};\n\n\n/**\n * @param {*=} opt_reason\n * @return {!CancellablePromise} A new Promise that is immediately rejected with the\n *     given reason.\n */\nCancellablePromise.reject = function(opt_reason) {\n  return new CancellablePromise(function(resolve, reject) {\n      reject(opt_reason);\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the\n *     first Promise (or Promise-like) input to complete.\n * @template TYPE\n */\nCancellablePromise.race = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      if (!promises.length) {\n        resolve(undefined);\n      }\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(resolve, reject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of\n *     every fulfilled value once every input Promise (or Promise-like) is\n *     successfully fulfilled, or is rejected by the first rejection result.\n * @template TYPE\n */\nCancellablePromise.all = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toFulfill = promises.length;\n      var values = [];\n\n      if (!toFulfill) {\n        resolve(values);\n        return;\n      }\n\n      var onFulfill = function(index, value) {\n        toFulfill--;\n        values[index] = value;\n        if (toFulfill === 0) {\n          resolve(values);\n        }\n      };\n\n      var onReject = function(reason) {\n        reject(reason);\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(partial(onFulfill, i), onReject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of\n *     the first input to be fulfilled, or is rejected with a list of every\n *     rejection reason if all inputs are rejected.\n * @template TYPE\n */\nCancellablePromise.firstFulfilled = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toReject = promises.length;\n      var reasons = [];\n\n      if (!toReject) {\n        resolve(undefined);\n        return;\n      }\n\n      var onFulfill = function(value) {\n        resolve(value);\n      };\n\n      var onReject = function(index, reason) {\n        toReject--;\n        reasons[index] = reason;\n        if (toReject === 0) {\n          reject(reasons);\n        }\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(onFulfill, partial(onReject, i));\n      }\n    });\n};\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise, returning a\n * new child Promise.\n *\n * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked\n * with the fulfillment value as argument, and the child Promise will be\n * fulfilled with the return value of the callback. If the callback throws an\n * exception, the child Promise will be rejected with the thrown value instead.\n *\n * If the Promise is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value (or thrown value) of the callback.\n *\n * @override\n */\nCancellablePromise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  return this.addChildPromise_(\n    core.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\n    core.isFunction(opt_onRejected) ? opt_onRejected : null,\n    opt_context);\n};\nThenable.addImplementation(CancellablePromise);\n\n\n/**\n * Adds a callback that will be invoked whether the Promise is fulfilled or\n * rejected. The callback receives no argument, and no new child Promise is\n * created. This is useful for ensuring that cleanup takes place after certain\n * asynchronous operations. Callbacks added with {@code thenAlways} will be\n * executed in the same order with other calls to {@code then},\n * {@code thenAlways}, or {@code thenCatch}.\n *\n * Since it does not produce a new child Promise, cancellation propagation is\n * not prevented by adding callbacks with {@code thenAlways}. A Promise that has\n * a cleanup handler added with {@code thenAlways} will be canceled if all of\n * its children created by {@code then} (or {@code thenCatch}) are canceled.\n *\n * @param {function(this:THIS): void} onResolved A function that will be invoked\n *     when the Promise is resolved.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.\n * @template THIS\n */\nCancellablePromise.prototype.thenAlways = function(onResolved, opt_context) {\n  var callback = function() {\n    try {\n      // Ensure that no arguments are passed to onResolved.\n      onResolved.call(opt_context);\n    } catch (err) {\n      CancellablePromise.handleRejection_.call(null, err);\n    }\n  };\n\n  this.addCallbackEntry_({\n    child: null,\n    onRejected: callback,\n    onFulfilled: callback\n  });\n  return this;\n};\n\n\n/**\n * Adds a callback that will be invoked only if the Promise is rejected. This\n * is equivalent to {@code then(null, onRejected)}.\n *\n * @param {!function(this:THIS, *): *} onRejected A function that will be\n *     invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise} A new Promise that will receive the result of the\n *     callback.\n * @template THIS\n */\nCancellablePromise.prototype.thenCatch = function(onRejected, opt_context) {\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\n\n/**\n * Alias of {@link CancellablePromise.prototype.thenCatch}\n */\nCancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;\n\n\n/**\n * Cancels the Promise if it is still pending by rejecting it with a cancel\n * Error. No action is performed if the Promise is already resolved.\n *\n * All child Promises of the canceled Promise will be rejected with the same\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\n * is the only child of a pending Promise, the parent Promise will also be\n * canceled. Cancellation may propagate upward through multiple generations.\n *\n * @param {string=} opt_message An optional debugging message for describing the\n *     cancellation reason.\n */\nCancellablePromise.prototype.cancel = function(opt_message) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    async.run(function() {\n      var err = new CancellablePromise.CancellationError(opt_message);\n      err.IS_CANCELLATION_ERROR = true;\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\n\n\n/**\n * Cancels this Promise with the given error.\n *\n * @param {!Error} err The cancellation error.\n * @private\n */\nCancellablePromise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    if (this.parent_) {\n      // Cancel the Promise and remove it from the parent's child list.\n      this.parent_.cancelChild_(this, err);\n    } else {\n      this.resolve_(CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Cancels a child Promise from the list of callback entries. If the Promise has\n * not already been resolved, reject it with a cancel error. If there are no\n * other children in the list of callback entries, propagate the cancellation\n * by canceling this Promise as well.\n *\n * @param {!CancellablePromise} childPromise The Promise to cancel.\n * @param {!Error} err The cancel error to use for rejecting the Promise.\n * @private\n */\nCancellablePromise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childIndex = -1;\n\n  // Find the callback entry for the childPromise, and count whether there are\n  // additional child Promises.\n  for (var i = 0, entry; (entry = this.callbackEntries_[i]); i++) {\n    var child = entry.child;\n    if (child) {\n      childCount++;\n      if (child === childPromise) {\n        childIndex = i;\n      }\n      if (childIndex >= 0 && childCount > 1) {\n        break;\n      }\n    }\n  }\n\n  // If the child Promise was the only child, cancel this Promise as well.\n  // Otherwise, reject only the child Promise with the cancel error.\n  if (childIndex >= 0) {\n    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {\n      this.cancelInternal_(err);\n    } else {\n      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];\n      this.executeCallback_(\n        callbackEntry, CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Adds a callback entry to the current Promise, and schedules callback\n * execution if the Promise has already been resolved.\n *\n * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing\n *     {@code onFulfilled} and {@code onRejected} callbacks to execute after\n *     the Promise is resolved.\n * @private\n */\nCancellablePromise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if ((!this.callbackEntries_ || !this.callbackEntries_.length) &&\n    (this.state_ === CancellablePromise.State_.FULFILLED ||\n    this.state_ === CancellablePromise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  if (!this.callbackEntries_) {\n    this.callbackEntries_ = [];\n  }\n  this.callbackEntries_.push(callbackEntry);\n};\n\n\n/**\n * Creates a child Promise and adds it to the callback entry list. The result of\n * the child Promise is determined by the state of the parent Promise and the\n * result of the {@code onFulfilled} or {@code onRejected} callbacks as\n * specified in the Promise resolution procedure.\n *\n * @see http://promisesaplus.com/#the__method\n *\n * @param {?function(this:THIS, TYPE):\n *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that\n *     will be invoked if the Promise is fullfilled, or null.\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\n *     invoked if the Promise is rejected, or null.\n * @param {THIS=} opt_context An optional execution context for the callbacks.\n *     in the default calling context.\n * @return {!CancellablePromise} The child Promise.\n * @template RESULT,THIS\n * @private\n */\nCancellablePromise.prototype.addChildPromise_ = function(\nonFulfilled, onRejected, opt_context) {\n\n  var callbackEntry = {\n    child: null,\n    onFulfilled: null,\n    onRejected: null\n  };\n\n  callbackEntry.child = new CancellablePromise(function(resolve, reject) {\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n\n    // Invoke onRejected, or reject with the parent's reason if absent.\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (!core.isDef(result) && reason.IS_CANCELLATION_ERROR) {\n          // Propagate cancellation to children if no other result is returned.\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(\n    /** @type {CancellablePromise.CallbackEntry_} */ (callbackEntry));\n  return callbackEntry.child;\n};\n\n\n/**\n * Unblocks the Promise and fulfills it with the given value.\n *\n * @param {TYPE} value\n * @private\n */\nCancellablePromise.prototype.unblockAndFulfill_ = function(value) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.FULFILLED, value);\n};\n\n\n/**\n * Unblocks the Promise and rejects it with the given rejection reason.\n *\n * @param {*} reason\n * @private\n */\nCancellablePromise.prototype.unblockAndReject_ = function(reason) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.REJECTED, reason);\n};\n\n\n/**\n * Attempts to resolve a Promise with a given resolution state and value. This\n * is a no-op if the given Promise has already been resolved.\n *\n * If the given result is a Thenable (such as another Promise), the Promise will\n * be resolved with the same state and result as the Thenable once it is itself\n * resolved.\n *\n * If the given result is not a Thenable, the Promise will be fulfilled or\n * rejected with that result based on the given state.\n *\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\n *\n * @param {CancellablePromise.State_} state\n * @param {*} x The result to apply to the Promise.\n * @private\n */\nCancellablePromise.prototype.resolve_ = function(state, x) {\n  if (this.state_ !== CancellablePromise.State_.PENDING) {\n    return;\n  }\n\n  if (this === x) {\n    state = CancellablePromise.State_.REJECTED;\n    x = new TypeError('CancellablePromise cannot resolve to itself');\n\n  } else if (Thenable.isImplementedBy(x)) {\n    x = /** @type {!Thenable} */ (x);\n    this.state_ = CancellablePromise.State_.BLOCKED;\n    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);\n    return;\n\n  } else if (core.isObject(x)) {\n    try {\n      var then = x.then;\n      if (core.isFunction(then)) {\n        this.tryThen_(x, then);\n        return;\n      }\n    } catch (e) {\n      state = CancellablePromise.State_.REJECTED;\n      x = e;\n    }\n  }\n\n  this.result_ = x;\n  this.state_ = state;\n  this.scheduleCallbacks_();\n\n  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {\n    CancellablePromise.addUnhandledRejection_(this, x);\n  }\n};\n\n\n/**\n * Attempts to call the {@code then} method on an object in the hopes that it is\n * a Promise-compatible instance. This allows interoperation between different\n * Promise implementations, however a non-compliant object may cause a Promise\n * to hang indefinitely. If the {@code then} method throws an exception, the\n * dependent Promise will be rejected with the thrown value.\n *\n * @see http://promisesaplus.com/#point-70\n *\n * @param {Thenable} thenable An object with a {@code then} method that may be\n *     compatible with the Promise/A+ specification.\n * @param {!Function} then The {@code then} method of the Thenable object.\n * @private\n */\nCancellablePromise.prototype.tryThen_ = function(thenable, then) {\n  this.state_ = CancellablePromise.State_.BLOCKED;\n  var promise = this;\n  var called = false;\n\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      promise.unblockAndFulfill_(value);\n    }\n  };\n\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      promise.unblockAndReject_(reason);\n    }\n  };\n\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\n\n\n/**\n * Executes the pending callbacks of a resolved Promise after a timeout.\n *\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\n * callbacks must only be invoked from a call stack that only contains Promise\n * implementation code, which we accomplish by invoking callback execution after\n * a timeout. If {@code startExecution_} is called multiple times for the same\n * Promise, the callback chain will be evaluated only once. Additional callbacks\n * may be added during the evaluation phase, and will be executed in the same\n * event loop.\n *\n * All Promises added to the waiting list during the same browser event loop\n * will be executed in one batch to avoid using a separate timeout per Promise.\n *\n * @private\n */\nCancellablePromise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    async.run(this.executeCallbacks_, this);\n  }\n};\n\n\n/**\n * Executes all pending callbacks for this Promise.\n *\n * @private\n */\nCancellablePromise.prototype.executeCallbacks_ = function() {\n  while (this.callbackEntries_ && this.callbackEntries_.length) {\n    var entries = this.callbackEntries_;\n    this.callbackEntries_ = [];\n\n    for (var i = 0; i < entries.length; i++) {\n      this.executeCallback_(entries[i], this.state_, this.result_);\n    }\n  }\n  this.executing_ = false;\n};\n\n\n/**\n * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}\n * or {@code onRejected} callback based on the resolved state of the Promise.\n *\n * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the\n *     onFulfilled and/or onRejected callbacks for this step.\n * @param {CancellablePromise.State_} state The resolution status of the Promise,\n *     either FULFILLED or REJECTED.\n * @param {*} result The resolved result of the Promise.\n * @private\n */\nCancellablePromise.prototype.executeCallback_ = function(\ncallbackEntry, state, result) {\n  if (state === CancellablePromise.State_.FULFILLED) {\n    callbackEntry.onFulfilled(result);\n  } else {\n    this.removeUnhandledRejection_();\n    callbackEntry.onRejected(result);\n  }\n};\n\n\n/**\n * Marks this rejected Promise as having being handled. Also marks any parent\n * Promises in the rejected state as handled. The rejection handler will no\n * longer be invoked for this Promise (if it has not been called already).\n *\n * @private\n */\nCancellablePromise.prototype.removeUnhandledRejection_ = function() {\n  var p;\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n      p.hadUnhandledRejection_ = false;\n    }\n  }\n};\n\n\n/**\n * Marks this rejected Promise as unhandled. If no {@code onRejected} callback\n * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}\n * expires, the reason will be passed to the unhandled rejection handler. The\n * handler typically rethrows the rejection reason so that it becomes visible in\n * the developer console.\n *\n * @param {!CancellablePromise} promise The rejected Promise.\n * @param {*} reason The Promise rejection reason.\n * @private\n */\nCancellablePromise.addUnhandledRejection_ = function(promise, reason) {\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = setTimeout(function() {\n      CancellablePromise.handleRejection_.call(null, reason);\n    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);\n\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    promise.hadUnhandledRejection_ = true;\n    async.run(function() {\n      if (promise.hadUnhandledRejection_) {\n        CancellablePromise.handleRejection_.call(null, reason);\n      }\n    });\n  }\n};\n\n\n/**\n * A method that is invoked with the rejection reasons for Promises that are\n * rejected but have no {@code onRejected} callbacks registered yet.\n * @type {function(*)}\n * @private\n */\nCancellablePromise.handleRejection_ = async.throwException;\n\n\n/**\n * Sets a handler that will be called with reasons from unhandled rejected\n * Promises. If the rejected Promise (or one of its descendants) has an\n * {@code onRejected} callback registered, the rejection will be considered\n * handled, and the rejection handler will not be called.\n *\n * By default, unhandled rejections are rethrown so that the error may be\n * captured by the developer console or a {@code window.onerror} handler.\n *\n * @param {function(*)} handler A function that will be called with reasons from\n *     rejected Promises. Defaults to {@code async.throwException}.\n */\nCancellablePromise.setUnhandledRejectionHandler = function(handler) {\n  CancellablePromise.handleRejection_ = handler;\n};\n\n\n\n/**\n * Error used as a rejection reason for canceled Promises.\n *\n * @param {string=} opt_message\n * @constructor\n * @extends {Error}\n * @final\n */\nCancellablePromise.CancellationError = class extends Error {\n  constructor(opt_message) {\n     super(opt_message);\n\n     if (opt_message) {\n       this.message = opt_message;\n     }\n   }\n};\n\n/** @override */\nCancellablePromise.CancellationError.prototype.name = 'cancel';\n\nexport {CancellablePromise};\nexport default CancellablePromise;\n"],"sourceRoot":"/source/"}