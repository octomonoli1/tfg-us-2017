{"version":3,"sources":["/source/incremental-dom.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBC,aAAU,MAAV,EAAkB,OAAlB,EAA2B;AACzB,YAAS,OAAO,cAAP,GAAwB,OAAO,cAAP,IAAyB,EAA1D,CAAD;AACD,GAFA,EAEC,MAFD,EAES,UAAU,OAAV,EAAmB;AAAE;;;;;;;;;;;;;;;;;;;;;;AAqB7B,QAAI,iBAAiB,OAAO,SAAP,CAAiB,cAAtC;;;;;AAKA,QAAI,SAAS,OAAO,MAApB;;;;;;;;AAQA,QAAI,MAAM,SAAN,GAAM,CAAU,GAAV,EAAe,QAAf,EAAyB;AACjC,aAAO,eAAe,IAAf,CAAoB,GAApB,EAAyB,QAAzB,CAAP;AACD,KAFD;;;;;;AAQA,QAAI,YAAY,SAAZ,SAAY,GAAY;AAC1B,aAAO,OAAO,IAAP,CAAP;AACD,KAFD;;;;;;;;AAUA,aAAS,QAAT,CAAkB,QAAlB,EAA4B,GAA5B,EAAiC;;;;;AAK/B,WAAK,KAAL,GAAa,WAAb;;;;;;;;AAQA,WAAK,QAAL,GAAgB,EAAhB;;;;;;AAMA,WAAK,QAAL,GAAgB,WAAhB;;;;;;;AAOA,WAAK,GAAL,GAAW,GAAX;;;;;;AAMA,WAAK,MAAL,GAAc,IAAd;;;;;;AAMA,WAAK,WAAL,GAAmB,IAAnB;;;;;;AAMA,WAAK,QAAL,GAAgB,QAAhB;;;;;AAKA,WAAK,IAAL,GAAY,IAAZ;AACD;;;;;;;;;;AAUD,QAAI,WAAW,SAAX,QAAW,CAAU,IAAV,EAAgB,QAAhB,EAA0B,GAA1B,EAA+B;AAC5C,UAAI,OAAO,IAAI,QAAJ,CAAa,QAAb,EAAuB,GAAvB,CAAX;AACA,WAAK,sBAAL,IAA+B,IAA/B;AACA,aAAO,IAAP;AACD,KAJD;;;;;;;;AAYA,QAAI,UAAU,SAAV,OAAU,CAAU,IAAV,EAAgB;AAC5B,UAAI,OAAO,KAAK,sBAAL,CAAX;;AAEA,UAAI,CAAC,IAAL,EAAW;AACT,YAAI,WAAW,KAAK,QAAL,CAAc,WAAd,EAAf;AACA,YAAI,MAAM,IAAV;;AAEA,YAAI,gBAAgB,OAApB,EAA6B;AAC3B,gBAAM,KAAK,YAAL,CAAkB,KAAlB,CAAN;AACD;;AAED,eAAO,SAAS,IAAT,EAAe,QAAf,EAAyB,GAAzB,CAAP;AACD;;AAED,aAAO,IAAP;AACD,KAfD;;;;;;;;;;;;;;;;;;;AAkCA,QAAI,UAAU;AACZ,eAAS,WADG;;AAGZ,mBAAa;AAHD,KAAd;;;;;;AAUA,QAAI,eAAe,SAAf,YAAe,CAAU,IAAV,EAAgB;AACjC,UAAI,KAAK,WAAL,CAAiB,MAAjB,EAAyB,CAAzB,MAAgC,CAApC,EAAuC;AACrC,eAAO,sCAAP;AACD;;AAED,UAAI,KAAK,WAAL,CAAiB,QAAjB,EAA2B,CAA3B,MAAkC,CAAtC,EAAyC;AACvC,eAAO,8BAAP;AACD;AACF,KARD;;;;;;;;;;AAkBA,QAAI,YAAY,SAAZ,SAAY,CAAU,EAAV,EAAc,IAAd,EAAoB,KAApB,EAA2B;AACzC,UAAI,SAAS,IAAb,EAAmB;AACjB,WAAG,eAAH,CAAmB,IAAnB;AACD,OAFD,MAEO;AACL,YAAI,SAAS,aAAa,IAAb,CAAb;AACA,YAAI,MAAJ,EAAY;AACV,aAAG,cAAH,CAAkB,MAAlB,EAA0B,IAA1B,EAAgC,KAAhC;AACD,SAFD,MAEO;AACL,aAAG,YAAH,CAAgB,IAAhB,EAAsB,KAAtB;AACD;AACF;AACF,KAXD;;;;;;;;AAmBA,QAAI,YAAY,SAAZ,SAAY,CAAU,EAAV,EAAc,IAAd,EAAoB,KAApB,EAA2B;AACzC,SAAG,IAAH,IAAW,KAAX;AACD,KAFD;;;;;;;;;;AAYA,QAAI,aAAa,SAAb,UAAa,CAAU,EAAV,EAAc,IAAd,EAAoB,KAApB,EAA2B;AAC1C,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAG,KAAH,CAAS,OAAT,GAAmB,KAAnB;AACD,OAFD,MAEO;AACL,WAAG,KAAH,CAAS,OAAT,GAAmB,EAAnB;AACA,YAAI,UAAU,GAAG,KAAjB;AACA,YAAI,M,qCAA2C,KAA/C;;AAEA,aAAK,IAAI,IAAT,IAAiB,GAAjB,EAAsB;AACpB,cAAI,IAAI,GAAJ,EAAS,IAAT,CAAJ,EAAoB;AAClB,oBAAQ,IAAR,IAAgB,IAAI,IAAJ,CAAhB;AACD;AACF;AACF;AACF,KAdD;;;;;;;;;;AAwBA,QAAI,sBAAsB,SAAtB,mBAAsB,CAAU,EAAV,EAAc,IAAd,EAAoB,KAApB,EAA2B;AACnD,UAAI,cAAc,KAAd,yCAAc,KAAd,CAAJ;;AAEA,UAAI,SAAS,QAAT,IAAqB,SAAS,UAAlC,EAA8C;AAC5C,kBAAU,EAAV,EAAc,IAAd,EAAoB,KAApB;AACD,OAFD,MAEO;AACL,kBAAU,EAAV,EAAc,IAAd,E,uCAA2D,KAA3D;AACD;AACF,KARD;;;;;;;;AAgBA,QAAI,kBAAkB,SAAlB,eAAkB,CAAU,EAAV,EAAc,IAAd,EAAoB,KAApB,EAA2B;AAC/C,UAAI,OAAO,QAAQ,EAAR,CAAX;AACA,UAAI,QAAQ,KAAK,KAAjB;;AAEA,UAAI,MAAM,IAAN,MAAgB,KAApB,EAA2B;AACzB;AACD;;AAED,UAAI,UAAU,WAAW,IAAX,KAAoB,WAAW,QAAQ,OAAnB,CAAlC;AACA,cAAQ,EAAR,EAAY,IAAZ,EAAkB,KAAlB;;AAEA,YAAM,IAAN,IAAc,KAAd;AACD,KAZD;;;;;;AAkBA,QAAI,aAAa,WAAjB;;;;AAIA,eAAW,QAAQ,OAAnB,IAA8B,mBAA9B;;AAEA,eAAW,QAAQ,WAAnB,IAAkC,YAAY,CAAE,CAAhD;;AAEA,eAAW,OAAX,IAAsB,UAAtB;;;;;;;;AAQA,QAAI,qBAAqB,SAArB,kBAAqB,CAAU,GAAV,EAAe,MAAf,EAAuB;AAC9C,UAAI,QAAQ,KAAZ,EAAmB;AACjB,eAAO,4BAAP;AACD;;AAED,UAAI,QAAQ,MAAR,EAAgB,QAAhB,KAA6B,eAAjC,EAAkD;AAChD,eAAO,IAAP;AACD;;AAED,aAAO,OAAO,YAAd;AACD,KAVD;;;;;;;;;;;;AAsBA,QAAI,gBAAgB,SAAhB,aAAgB,CAAU,GAAV,EAAe,MAAf,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,OAAjC,EAA0C;AAC5D,UAAI,YAAY,mBAAmB,GAAnB,EAAwB,MAAxB,CAAhB;AACA,UAAI,KAAK,SAAT;;AAEA,UAAI,SAAJ,EAAe;AACb,aAAK,IAAI,eAAJ,CAAoB,SAApB,EAA+B,GAA/B,CAAL;AACD,OAFD,MAEO;AACL,aAAK,IAAI,aAAJ,CAAkB,GAAlB,CAAL;AACD;;AAED,eAAS,EAAT,EAAa,GAAb,EAAkB,GAAlB;;AAEA,UAAI,OAAJ,EAAa;AACX,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,KAAK,CAAzC,EAA4C;AAC1C,0BAAgB,EAAhB,E,qBAAyC,QAAQ,CAAR,CAAzC,EAAqD,QAAQ,IAAI,CAAZ,CAArD;AACD;AACF;;AAED,aAAO,EAAP;AACD,KAnBD;;;;;;;AA0BA,QAAI,aAAa,SAAb,UAAa,CAAU,GAAV,EAAe;AAC9B,UAAI,OAAO,IAAI,cAAJ,CAAmB,EAAnB,CAAX;AACA,eAAS,IAAT,EAAe,OAAf,EAAwB,IAAxB;AACA,aAAO,IAAP;AACD,KAJD;;;;;;;;AAYA,QAAI,eAAe,SAAf,YAAe,CAAU,EAAV,EAAc;AAC/B,UAAI,MAAM,WAAV;AACA,UAAI,QAAQ,GAAG,iBAAf;;AAEA,aAAO,KAAP,EAAc;AACZ,YAAI,MAAM,QAAQ,KAAR,EAAe,GAAzB;;AAEA,YAAI,GAAJ,EAAS;AACP,cAAI,GAAJ,IAAW,KAAX;AACD;;AAED,gBAAQ,MAAM,kBAAd;AACD;;AAED,aAAO,GAAP;AACD,KAfD;;;;;;;;AAuBA,QAAI,YAAY,SAAZ,SAAY,CAAU,EAAV,EAAc;AAC5B,UAAI,OAAO,QAAQ,EAAR,CAAX;;AAEA,UAAI,CAAC,KAAK,MAAV,EAAkB;AAChB,aAAK,MAAL,GAAc,aAAa,EAAb,CAAd;AACD;;AAED,aAAO,KAAK,MAAZ;AACD,KARD;;;;;;;;AAgBA,QAAI,WAAW,SAAX,QAAW,CAAU,MAAV,EAAkB,GAAlB,EAAuB;AACpC,aAAO,MAAM,UAAU,MAAV,EAAkB,GAAlB,CAAN,GAA+B,IAAtC;AACD,KAFD;;;;;;;;;;AAYA,QAAI,gBAAgB,SAAhB,aAAgB,CAAU,MAAV,EAAkB,GAAlB,EAAuB,KAAvB,EAA8B;AAChD,gBAAU,MAAV,EAAkB,GAAlB,IAAyB,KAAzB;AACD,KAFD;;;;;;;;;;;;;;;;;;;AAqBA,QAAI,gBAAgB;;;;;;AAMlB,oBAAc,IANI;;;;;;;;AAclB,oBAAc;AAdI,KAApB;;;;;;AAqBA,aAAS,OAAT,GAAmB;;;;AAIjB,WAAK,OAAL,GAAe,cAAc,YAAd,IAA8B,EAA7C;;;;;AAKA,WAAK,OAAL,GAAe,cAAc,YAAd,IAA8B,EAA7C;AACD;;;;;AAKD,YAAQ,SAAR,CAAkB,WAAlB,GAAgC,UAAU,IAAV,EAAgB;AAC9C,UAAI,KAAK,OAAT,EAAkB;AAChB,aAAK,OAAL,CAAa,IAAb,CAAkB,IAAlB;AACD;AACF,KAJD;;;;;AASA,YAAQ,SAAR,CAAkB,WAAlB,GAAgC,UAAU,IAAV,EAAgB;AAC9C,UAAI,KAAK,OAAT,EAAkB;AAChB,aAAK,OAAL,CAAa,IAAb,CAAkB,IAAlB;AACD;AACF,KAJD;;;;;AASA,YAAQ,SAAR,CAAkB,aAAlB,GAAkC,YAAY;AAC5C,UAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,MAAb,GAAsB,CAA1C,EAA6C;AAC3C,sBAAc,YAAd,CAA2B,KAAK,OAAhC;AACD;;AAED,UAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,MAAb,GAAsB,CAA1C,EAA6C;AAC3C,sBAAc,YAAd,CAA2B,KAAK,OAAhC;AACD;AACF,KARD;;;;;;;;AAgBA,QAAI,wBAAwB,SAAxB,qBAAwB,CAAU,QAAV,EAAoB,GAApB,EAAyB,GAAzB,EAA8B;AACxD,UAAI,aAAa,GAAjB,EAAsB;AACpB,cAAM,IAAI,KAAJ,CAAU,kCAAkC,GAAlC,GAAwC,YAAxC,GAAuD,GAAvD,GAA6D,UAA7D,GAA0E,QAA1E,GAAqF,GAA/F,CAAN;AACD;AACF,KAJD;;;AAOA,QAAI,UAAU,IAAd;;;AAGA,QAAI,cAAc,IAAlB;;;AAGA,QAAI,gBAAgB,IAApB;;;AAGA,QAAI,OAAO,IAAX;;;AAGA,QAAI,MAAM,IAAV;;;;;;;;;AASA,QAAI,eAAe,SAAf,YAAe,CAAU,GAAV,EAAe;;;;;;;;;;AAUhC,UAAI,IAAI,SAAJ,CAAI,CAAU,IAAV,EAAgB,EAAhB,EAAoB,IAApB,EAA0B;AAChC,YAAI,cAAc,OAAlB;AACA,YAAI,WAAW,IAAf;AACA,YAAI,UAAU,GAAd;AACA,YAAI,kBAAkB,WAAtB;AACA,YAAI,oBAAoB,aAAxB;AACA,YAAI,uBAAuB,KAA3B;AACA,YAAI,iBAAiB,KAArB;;AAEA,kBAAU,IAAI,OAAJ,EAAV;AACA,eAAO,IAAP;AACA,cAAM,KAAK,aAAX;AACA,wBAAgB,KAAK,UAArB;;AAEA,YAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,YAAI,IAAJ,EAAU,EAAV,EAAc,IAAd;;AAEA,YAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,gBAAQ,aAAR;;AAEA,kBAAU,WAAV;AACA,eAAO,QAAP;AACA,cAAM,OAAN;AACA,sBAAc,eAAd;AACA,wBAAgB,iBAAhB;AACD,OA3BD;AA4BA,aAAO,CAAP;AACD,KAvCD;;;;;;;;;;;;AAmDA,QAAI,aAAa,aAAa,UAAU,IAAV,EAAgB,EAAhB,EAAoB,IAApB,EAA0B;AACtD,oBAAc,IAAd;;AAEA;AACA,SAAG,IAAH;AACA;;AAEA,UAAI,iBAAiB,YAArB,EAAmC,CAAE;AACtC,KARgB,CAAjB;;;;;;;;;;;;AAoBA,QAAI,aAAa,aAAa,UAAU,IAAV,EAAgB,EAAhB,EAAoB,IAApB,EAA0B;AACtD,oB,uBAAqC,EAAE,aAAa,IAAf,EAArC;;AAEA,SAAG,IAAH;;AAEA,UAAI,iBAAiB,YAArB,EAAmC,CAAE;AACtC,KANgB,CAAjB;;;;;;;;;;AAgBA,QAAI,UAAU,SAAV,OAAU,CAAU,QAAV,EAAoB,GAApB,EAAyB;AACrC,UAAI,OAAO,QAAQ,WAAR,CAAX;;;;;AAKA,aAAO,aAAa,KAAK,QAAlB,IAA8B,OAAO,KAAK,GAAjD;AACD,KAPD;;;;;;;;;;;AAkBA,QAAI,eAAe,SAAf,YAAe,CAAU,QAAV,EAAoB,GAApB,EAAyB,OAAzB,EAAkC;AACnD,UAAI,eAAe,QAAQ,QAAR,EAAkB,GAAlB,CAAnB,EAA2C;AACzC;AACD;;AAED,UAAI,OAAO,SAAX;;;AAGA,UAAI,GAAJ,EAAS;AACP,eAAO,SAAS,aAAT,EAAwB,GAAxB,CAAP;AACA,YAAI,QAAQ,iBAAiB,YAA7B,EAA2C;AACzC,gCAAsB,QAAQ,IAAR,EAAc,QAApC,EAA8C,QAA9C,EAAwD,GAAxD;AACD;AACF;;;AAGD,UAAI,CAAC,IAAL,EAAW;AACT,YAAI,aAAa,OAAjB,EAA0B;AACxB,iBAAO,WAAW,GAAX,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,cAAc,GAAd,EAAmB,aAAnB,EAAkC,QAAlC,EAA4C,GAA5C,EAAiD,OAAjD,CAAP;AACD;;AAED,YAAI,GAAJ,EAAS;AACP,wBAAc,aAAd,EAA6B,GAA7B,EAAkC,IAAlC;AACD;;AAED,gBAAQ,WAAR,CAAoB,IAApB;AACD;;;;;;AAMD,UAAI,eAAe,QAAQ,WAAR,EAAqB,GAAxC,EAA6C;AAC3C,sBAAc,YAAd,CAA2B,IAA3B,EAAiC,WAAjC;AACA,gBAAQ,aAAR,EAAuB,WAAvB,GAAqC,KAArC;AACD,OAHD,MAGO;AACL,sBAAc,YAAd,CAA2B,IAA3B,EAAiC,WAAjC;AACD;;AAED,oBAAc,IAAd;AACD,KA1CD;;;;;;AAgDA,QAAI,oBAAoB,SAApB,iBAAoB,GAAY;AAClC,UAAI,OAAO,aAAX;AACA,UAAI,OAAO,QAAQ,IAAR,CAAX;AACA,UAAI,SAAS,KAAK,MAAlB;AACA,UAAI,cAAc,KAAK,WAAvB;AACA,UAAI,QAAQ,KAAK,SAAjB;AACA,UAAI,MAAM,SAAV;;AAEA,UAAI,UAAU,WAAV,IAAyB,WAA7B,EAA0C;AACxC;AACD;;AAED,UAAI,KAAK,KAAL,CAAW,QAAQ,WAAnB,KAAmC,SAAS,IAAhD,EAAsD;AACpD,YAAI,iBAAiB,YAArB,EAAmC,CAAE;AACrC;AACD;;AAED,aAAO,UAAU,WAAjB,EAA8B;AAC5B,aAAK,WAAL,CAAiB,KAAjB;AACA,gBAAQ,WAAR,C,oBAAwC,KAAxC;;AAEA,cAAM,QAAQ,KAAR,EAAe,GAArB;AACA,YAAI,GAAJ,EAAS;AACP,iBAAO,OAAO,GAAP,CAAP;AACD;AACD,gBAAQ,KAAK,SAAb;AACD;;;AAGD,UAAI,CAAC,WAAL,EAAkB;AAChB,aAAK,GAAL,IAAY,MAAZ,EAAoB;AAClB,kBAAQ,OAAO,GAAP,CAAR;AACA,cAAI,MAAM,UAAN,KAAqB,IAAzB,EAA+B;AAC7B,oBAAQ,WAAR,CAAoB,KAApB;AACA,mBAAO,OAAO,GAAP,CAAP;AACD;AACF;;AAED,aAAK,WAAL,GAAmB,IAAnB;AACD;AACF,KAxCD;;;;;AA6CA,QAAI,YAAY,SAAZ,SAAY,GAAY;AAC1B,sBAAgB,WAAhB;AACA,oBAAc,IAAd;AACD,KAHD;;;;;AAQA,QAAI,WAAW,SAAX,QAAW,GAAY;AACzB,UAAI,WAAJ,EAAiB;AACf,sBAAc,YAAY,WAA1B;AACD,OAFD,MAEO;AACL,sBAAc,cAAc,UAA5B;AACD;AACF,KAND;;;;;AAWA,QAAI,WAAW,SAAX,QAAW,GAAY;AACzB;;AAEA,oBAAc,aAAd;AACA,sBAAgB,cAAc,UAA9B;AACD,KALD;;;;;;;;;;;;;;;AAoBA,QAAI,kBAAkB,SAAlB,eAAkB,CAAU,GAAV,EAAe,GAAf,EAAoB,OAApB,EAA6B;AACjD;AACA,mBAAa,GAAb,EAAkB,GAAlB,EAAuB,OAAvB;AACA;AACA,a,wBAA+B;AAA/B;AAED,KAND;;;;;;;;AAcA,QAAI,mBAAmB,SAAnB,gBAAmB,GAAY;AACjC,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC;AACA,a,wBAA+B;AAA/B;AAED,KAND;;;;;;;;AAcA,QAAI,WAAW,SAAX,QAAW,GAAY;AACzB;AACA,mBAAa,OAAb,EAAsB,IAAtB,EAA4B,IAA5B;AACA,a,qBAA4B;AAA5B;AAED,KALD;;;;;;AAWA,QAAI,iBAAiB,SAAjB,cAAiB,GAAY;AAC/B,UAAI,iBAAiB,YAArB,EAAmC,CAAE;AACrC,a,wBAA+B;AAA/B;AAED,KAJD;;;;;;AAUA,QAAI,OAAO,SAAP,IAAO,GAAY;AACrB,UAAI,iBAAiB,YAArB,EAAmC,CAAE;AACrC,oBAAc,cAAc,SAA5B;AACD,KAHD;;;;;;;AAUA,QAAI,oBAAoB,CAAxB;;;;;;;AAOA,QAAI,cAAc,EAAlB;;;;;;;;;;;;;;AAcA,QAAI,cAAc,SAAd,WAAc,CAAU,GAAV,EAAe,GAAf,EAAoB,OAApB,EAA6B,UAA7B,EAAyC;AACzD,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,UAAI,OAAO,gBAAgB,GAAhB,EAAqB,GAArB,EAA0B,OAA1B,CAAX;AACA,UAAI,OAAO,QAAQ,IAAR,CAAX;;;;;;;;AAQA,UAAI,WAAW,KAAK,QAApB;AACA,UAAI,WAAW,KAAK,QAApB;AACA,UAAI,eAAe,KAAnB;AACA,UAAI,IAAI,iBAAR;AACA,UAAI,IAAI,CAAR;;AAEA,aAAO,IAAI,UAAU,MAArB,EAA6B,KAAK,CAAL,EAAQ,KAAK,CAA1C,EAA6C;AAC3C,YAAI,SAAS,CAAT,MAAgB,UAAU,CAAV,CAApB,EAAkC;AAChC,yBAAe,IAAf;AACA;AACD;AACF;;AAED,aAAO,IAAI,UAAU,MAArB,EAA6B,KAAK,CAAL,EAAQ,KAAK,CAA1C,EAA6C;AAC3C,iBAAS,CAAT,IAAc,UAAU,CAAV,CAAd;AACD;;AAED,UAAI,IAAI,SAAS,MAAjB,EAAyB;AACvB,uBAAe,IAAf;AACA,iBAAS,MAAT,GAAkB,CAAlB;AACD;;;;;AAKD,UAAI,YAAJ,EAAkB;AAChB,aAAK,IAAI,iBAAT,EAA4B,IAAI,UAAU,MAA1C,EAAkD,KAAK,CAAvD,EAA0D;AACxD,mBAAS,UAAU,CAAV,CAAT,IAAyB,UAAU,IAAI,CAAd,CAAzB;AACD;;AAED,aAAK,IAAI,KAAT,IAAkB,QAAlB,EAA4B;AAC1B,0BAAgB,IAAhB,EAAsB,KAAtB,EAA6B,SAAS,KAAT,CAA7B;AACA,mBAAS,KAAT,IAAkB,SAAlB;AACD;AACF;;AAED,aAAO,IAAP;AACD,KAjDD;;;;;;;;;;;;;;;;AAiEA,QAAI,mBAAmB,SAAnB,gBAAmB,CAAU,GAAV,EAAe,GAAf,EAAoB,OAApB,EAA6B;AAClD,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,kBAAY,CAAZ,IAAiB,GAAjB;AACA,kBAAY,CAAZ,IAAiB,GAAjB;AACA,kBAAY,CAAZ,IAAiB,OAAjB;AACD,KAND;;;;;;;;;AAeA,QAAI,OAAO,SAAP,IAAO,CAAU,IAAV,EAAgB,KAAhB,EAAuB;AAChC,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,kBAAY,IAAZ,CAAiB,IAAjB,EAAuB,KAAvB;AACD,KAJD;;;;;;AAUA,QAAI,iBAAiB,SAAjB,cAAiB,GAAY;AAC/B,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,UAAI,OAAO,YAAY,KAAZ,CAAkB,IAAlB,EAAwB,WAAxB,CAAX;AACA,kBAAY,MAAZ,GAAqB,CAArB;AACA,aAAO,IAAP;AACD,KAND;;;;;;;;AAcA,QAAI,eAAe,SAAf,YAAe,CAAU,GAAV,EAAe;AAChC,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,UAAI,OAAO,kBAAX;;AAEA,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,aAAO,IAAP;AACD,KARD;;;;;;;;;;;;;;;;AAwBA,QAAI,cAAc,SAAd,WAAc,CAAU,GAAV,EAAe,GAAf,EAAoB,OAApB,EAA6B,UAA7B,EAAyC;AACzD,kBAAY,KAAZ,CAAkB,IAAlB,EAAwB,SAAxB;AACA,aAAO,aAAa,GAAb,CAAP;AACD,KAHD;;;;;;;;;;;;;;;;;;;AAsBA,QAAI,qBAAqB,SAArB,kBAAqB,CAAU,GAAV,EAAe,GAAf,EAAoB,OAApB,EAA6B,UAA7B,EAAyC;AAChE,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,kBAAY,KAAZ,CAAkB,IAAlB,EAAwB,SAAxB;AACA;AACA,aAAO,aAAa,GAAb,CAAP;AACD,KAND;;;;;;;;;;;AAiBA,QAAI,OAAO,SAAP,IAAO,CAAU,KAAV,EAAiB,UAAjB,EAA6B;AACtC,UAAI,iBAAiB,YAArB,EAAmC,CAAE;;AAErC,UAAI,OAAO,UAAX;AACA,UAAI,OAAO,QAAQ,IAAR,CAAX;;AAEA,UAAI,KAAK,IAAL,KAAc,KAAlB,EAAyB;AACvB,aAAK,IAAL,G,qBAAiC,KAAjC;;AAEA,YAAI,YAAY,KAAhB;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAAU,MAA9B,EAAsC,KAAK,CAA3C,EAA8C;;;;;AAK5C,cAAI,KAAK,UAAU,CAAV,CAAT;AACA,sBAAY,GAAG,SAAH,CAAZ;AACD;;AAED,aAAK,IAAL,GAAY,SAAZ;AACD;;AAED,aAAO,IAAP;AACD,KAvBD;;AAyBA,YAAQ,KAAR,GAAgB,UAAhB;AACA,YAAQ,UAAR,GAAqB,UAArB;AACA,YAAQ,UAAR,GAAqB,UAArB;AACA,YAAQ,cAAR,GAAyB,cAAzB;AACA,YAAQ,IAAR,GAAe,IAAf;AACA,YAAQ,WAAR,GAAsB,WAAtB;AACA,YAAQ,gBAAR,GAA2B,gBAA3B;AACA,YAAQ,cAAR,GAAyB,cAAzB;AACA,YAAQ,WAAR,GAAsB,WAAtB;AACA,YAAQ,YAAR,GAAuB,YAAvB;AACA,YAAQ,kBAAR,GAA6B,kBAA7B;AACA,YAAQ,IAAR,GAAe,IAAf;AACA,YAAQ,IAAR,GAAe,IAAf;AACA,YAAQ,OAAR,GAAkB,OAAlB;AACA,YAAQ,UAAR,GAAqB,UAArB;AACA,YAAQ,SAAR,GAAoB,SAApB;AACA,YAAQ,SAAR,GAAoB,SAApB;AACA,YAAQ,aAAR,GAAwB,aAAxB;AAED,GA3hCA,CAAD","sourcesContent":["/* jshint ignore:start */\n\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function (global, factory) {\n  (factory((global.IncrementalDOM = global.IncrementalDOM || {})))\n}(window, function (exports) { 'use strict';\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * A cached reference to the hasOwnProperty function.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * A cached reference to the create function.\n   */\n  var create = Object.create;\n\n  /**\n   * Used to prevent property collisions between our \"map\" and its prototype.\n   * @param {!Object<string, *>} map The map to check.\n   * @param {string} property The property to check.\n   * @return {boolean} Whether map has property.\n   */\n  var has = function (map, property) {\n    return hasOwnProperty.call(map, property);\n  };\n\n  /**\n   * Creates an map object without a prototype.\n   * @return {!Object}\n   */\n  var createMap = function () {\n    return create(null);\n  };\n\n  /**\n   * Keeps track of information needed to perform diffs for a given DOM node.\n   * @param {!string} nodeName\n   * @param {?string=} key\n   * @constructor\n   */\n  function NodeData(nodeName, key) {\n    /**\n     * The attributes and their values.\n     * @const {!Object<string, *>}\n     */\n    this.attrs = createMap();\n\n    /**\n     * An array of attribute name/value pairs, used for quickly diffing the\n     * incomming attributes to see if the DOM node's attributes need to be\n     * updated.\n     * @const {Array<*>}\n     */\n    this.attrsArr = [];\n\n    /**\n     * The incoming attributes for this Node, before they are updated.\n     * @const {!Object<string, *>}\n     */\n    this.newAttrs = createMap();\n\n    /**\n     * The key used to identify this node, used to preserve DOM nodes when they\n     * move within their parent.\n     * @const\n     */\n    this.key = key;\n\n    /**\n     * Keeps track of children within this node by their key.\n     * {?Object<string, !Element>}\n     */\n    this.keyMap = null;\n\n    /**\n     * Whether or not the keyMap is currently valid.\n     * {boolean}\n     */\n    this.keyMapValid = true;\n\n    /**\n     * The node name for this node.\n     * @const {string}\n     */\n    this.nodeName = nodeName;\n\n    /**\n     * @type {?string}\n     */\n    this.text = null;\n  }\n\n  /**\n   * Initializes a NodeData object for a Node.\n   *\n   * @param {Node} node The node to initialize data for.\n   * @param {string} nodeName The node name of node.\n   * @param {?string=} key The key that identifies the node.\n   * @return {!NodeData} The newly initialized data object\n   */\n  var initData = function (node, nodeName, key) {\n    var data = new NodeData(nodeName, key);\n    node['__incrementalDOMData'] = data;\n    return data;\n  };\n\n  /**\n   * Retrieves the NodeData object for a Node, creating it if necessary.\n   *\n   * @param {Node} node The node to retrieve the data for.\n   * @return {!NodeData} The NodeData for this Node.\n   */\n  var getData = function (node) {\n    var data = node['__incrementalDOMData'];\n\n    if (!data) {\n      var nodeName = node.nodeName.toLowerCase();\n      var key = null;\n\n      if (node instanceof Element) {\n        key = node.getAttribute('key');\n      }\n\n      data = initData(node, nodeName, key);\n    }\n\n    return data;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /** @const */\n  var symbols = {\n    default: '__default',\n\n    placeholder: '__placeholder'\n  };\n\n  /**\n   * @param {string} name\n   * @return {string|undefined} The namespace to use for the attribute.\n   */\n  var getNamespace = function (name) {\n    if (name.lastIndexOf('xml:', 0) === 0) {\n      return 'http://www.w3.org/XML/1998/namespace';\n    }\n\n    if (name.lastIndexOf('xlink:', 0) === 0) {\n      return 'http://www.w3.org/1999/xlink';\n    }\n  };\n\n  /**\n   * Applies an attribute or property to a given Element. If the value is null\n   * or undefined, it is removed from the Element. Otherwise, the value is set\n   * as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {?(boolean|number|string)=} value The attribute's value.\n   */\n  var applyAttr = function (el, name, value) {\n    if (value == null) {\n      el.removeAttribute(name);\n    } else {\n      var attrNS = getNamespace(name);\n      if (attrNS) {\n        el.setAttributeNS(attrNS, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    }\n  };\n\n  /**\n   * Applies a property to a given Element.\n   * @param {!Element} el\n   * @param {string} name The property's name.\n   * @param {*} value The property's value.\n   */\n  var applyProp = function (el, name, value) {\n    el[name] = value;\n  };\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} style The style to set. Either a string of css or an object\n   *     containing property-value pairs.\n   */\n  var applyStyle = function (el, name, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n      var elStyle = el.style;\n      var obj = /** @type {!Object<string,string>} */style;\n\n      for (var prop in obj) {\n        if (has(obj, prop)) {\n          elStyle[prop] = obj[prop];\n        }\n      }\n    }\n  };\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is an object or\n   *     function it is set on the Element, otherwise, it is set as an HTML\n   *     attribute.\n   */\n  var applyAttributeTyped = function (el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      applyProp(el, name, value);\n    } else {\n      applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n    }\n  };\n\n  /**\n   * Calls the appropriate attribute mutator for this attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value.\n   */\n  var updateAttribute = function (el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    var mutator = attributes[name] || attributes[symbols.default];\n    mutator(el, name, value);\n\n    attrs[name] = value;\n  };\n\n  /**\n   * A publicly mutable object to provide custom mutators for attributes.\n   * @const {!Object<string, function(!Element, string, *)>}\n   */\n  var attributes = createMap();\n\n  // Special generic mutator that's called for any attribute that does not\n  // have a specific mutator.\n  attributes[symbols.default] = applyAttributeTyped;\n\n  attributes[symbols.placeholder] = function () {};\n\n  attributes['style'] = applyStyle;\n\n  /**\n   * Gets the namespace to create an element (of a given tag) in.\n   * @param {string} tag The tag to get the namespace for.\n   * @param {?Node} parent\n   * @return {?string} The namespace to create the tag in.\n   */\n  var getNamespaceForTag = function (tag, parent) {\n    if (tag === 'svg') {\n      return 'http://www.w3.org/2000/svg';\n    }\n\n    if (getData(parent).nodeName === 'foreignObject') {\n      return null;\n    }\n\n    return parent.namespaceURI;\n  };\n\n  /**\n   * Creates an Element.\n   * @param {Document} doc The document with which to create the Element.\n   * @param {?Node} parent\n   * @param {string} tag The tag for the Element.\n   * @param {?string=} key A key to identify the Element.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element.\n   * @return {!Element}\n   */\n  var createElement = function (doc, parent, tag, key, statics) {\n    var namespace = getNamespaceForTag(tag, parent);\n    var el = undefined;\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, tag);\n    } else {\n      el = doc.createElement(tag);\n    }\n\n    initData(el, tag, key);\n\n    if (statics) {\n      for (var i = 0; i < statics.length; i += 2) {\n        updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n      }\n    }\n\n    return el;\n  };\n\n  /**\n   * Creates a Text Node.\n   * @param {Document} doc The document with which to create the Element.\n   * @return {!Text}\n   */\n  var createText = function (doc) {\n    var node = doc.createTextNode('');\n    initData(node, '#text', null);\n    return node;\n  };\n\n  /**\n   * Creates a mapping that can be used to look up children using a key.\n   * @param {?Node} el\n   * @return {!Object<string, !Element>} A mapping of keys to the children of the\n   *     Element.\n   */\n  var createKeyMap = function (el) {\n    var map = createMap();\n    var child = el.firstElementChild;\n\n    while (child) {\n      var key = getData(child).key;\n\n      if (key) {\n        map[key] = child;\n      }\n\n      child = child.nextElementSibling;\n    }\n\n    return map;\n  };\n\n  /**\n   * Retrieves the mapping of key to child node for a given Element, creating it\n   * if necessary.\n   * @param {?Node} el\n   * @return {!Object<string, !Node>} A mapping of keys to child Elements\n   */\n  var getKeyMap = function (el) {\n    var data = getData(el);\n\n    if (!data.keyMap) {\n      data.keyMap = createKeyMap(el);\n    }\n\n    return data.keyMap;\n  };\n\n  /**\n   * Retrieves a child from the parent with the given key.\n   * @param {?Node} parent\n   * @param {?string=} key\n   * @return {?Node} The child corresponding to the key.\n   */\n  var getChild = function (parent, key) {\n    return key ? getKeyMap(parent)[key] : null;\n  };\n\n  /**\n   * Registers an element as being a child. The parent will keep track of the\n   * child using the key. The child can be retrieved using the same key using\n   * getKeyMap. The provided key should be unique within the parent Element.\n   * @param {?Node} parent The parent of child.\n   * @param {string} key A key to identify the child with.\n   * @param {!Node} child The child to register.\n   */\n  var registerChild = function (parent, key, child) {\n    getKeyMap(parent)[key] = child;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /** @const */\n  var notifications = {\n    /**\n     * Called after patch has compleated with any Nodes that have been created\n     * and added to the DOM.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesCreated: null,\n\n    /**\n     * Called after patch has compleated with any Nodes that have been removed\n     * from the DOM.\n     * Note it's an applications responsibility to handle any childNodes.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesDeleted: null\n  };\n\n  /**\n   * Keeps track of the state of a patch.\n   * @constructor\n   */\n  function Context() {\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.created = notifications.nodesCreated && [];\n\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.deleted = notifications.nodesDeleted && [];\n  }\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markCreated = function (node) {\n    if (this.created) {\n      this.created.push(node);\n    }\n  };\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markDeleted = function (node) {\n    if (this.deleted) {\n      this.deleted.push(node);\n    }\n  };\n\n  /**\n   * Notifies about nodes that were created during the patch opearation.\n   */\n  Context.prototype.notifyChanges = function () {\n    if (this.created && this.created.length > 0) {\n      notifications.nodesCreated(this.created);\n    }\n\n    if (this.deleted && this.deleted.length > 0) {\n      notifications.nodesDeleted(this.deleted);\n    }\n  };\n\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!string} nodeName The nodeName of the node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function (nodeName, tag, key) {\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n    }\n  };\n\n  /** @type {?Context} */\n  var context = null;\n\n  /** @type {?Node} */\n  var currentNode = null;\n\n  /** @type {?Node} */\n  var currentParent = null;\n\n  /** @type {?Element|?DocumentFragment} */\n  var root = null;\n\n  /** @type {?Document} */\n  var doc = null;\n\n  /**\n   * Returns a patcher function that sets up and restores a patch context,\n   * running the run function with the provided data.\n   * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n   * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n   * @template T\n   */\n  var patchFactory = function (run) {\n    /**\n     * TODO(moz): These annotations won't be necessary once we switch to Closure\n     * Compiler's new type inference. Remove these once the switch is done.\n     *\n     * @param {(!Element|!DocumentFragment)} node\n     * @param {!function(T)} fn\n     * @param {T=} data\n     * @template T\n     */\n    var f = function (node, fn, data) {\n      var prevContext = context;\n      var prevRoot = root;\n      var prevDoc = doc;\n      var prevCurrentNode = currentNode;\n      var prevCurrentParent = currentParent;\n      var previousInAttributes = false;\n      var previousInSkip = false;\n\n      context = new Context();\n      root = node;\n      doc = node.ownerDocument;\n      currentParent = node.parentNode;\n\n      if ('production' !== 'production') {}\n\n      run(node, fn, data);\n\n      if ('production' !== 'production') {}\n\n      context.notifyChanges();\n\n      context = prevContext;\n      root = prevRoot;\n      doc = prevDoc;\n      currentNode = prevCurrentNode;\n      currentParent = prevCurrentParent;\n    };\n    return f;\n  };\n\n  /**\n   * Patches the document starting at node with the provided function. This\n   * function may be called during an existing patch operation.\n   * @param {!Element|!DocumentFragment} node The Element or Document\n   *     to patch.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @template T\n   */\n  var patchInner = patchFactory(function (node, fn, data) {\n    currentNode = node;\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if ('production' !== 'production') {}\n  });\n\n  /**\n   * Patches an Element with the the provided function. Exactly one top level\n   * element call should be made corresponding to `node`.\n   * @param {!Element} node The Element where the patch should start.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM. This should have at most one top level\n   *     element call.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @template T\n   */\n  var patchOuter = patchFactory(function (node, fn, data) {\n    currentNode = /** @type {!Element} */{ nextSibling: node };\n\n    fn(data);\n\n    if ('production' !== 'production') {}\n  });\n\n  /**\n   * Checks whether or not the current node matches the specified nodeName and\n   * key.\n   *\n   * @param {?string} nodeName The nodeName for this node.\n   * @param {?string=} key An optional key that identifies a node.\n   * @return {boolean} True if the node matches, false otherwise.\n   */\n  var matches = function (nodeName, key) {\n    var data = getData(currentNode);\n\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return nodeName === data.nodeName && key == data.key;\n  };\n\n  /**\n   * Aligns the virtual Element definition with the actual DOM, moving the\n   * corresponding DOM node to the correct location or creating it if necessary.\n   * @param {string} nodeName For an Element, this should be a valid tag string.\n   *     For a Text, this should be #text.\n   * @param {?string=} key The key used to identify this element.\n   * @param {?Array<*>=} statics For an Element, this should be an array of\n   *     name-value pairs.\n   */\n  var alignWithDOM = function (nodeName, key, statics) {\n    if (currentNode && matches(nodeName, key)) {\n      return;\n    }\n\n    var node = undefined;\n\n    // Check to see if the node has moved within the parent.\n    if (key) {\n      node = getChild(currentParent, key);\n      if (node && 'production' !== 'production') {\n        assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n      }\n    }\n\n    // Create the node if it doesn't exist.\n    if (!node) {\n      if (nodeName === '#text') {\n        node = createText(doc);\n      } else {\n        node = createElement(doc, currentParent, nodeName, key, statics);\n      }\n\n      if (key) {\n        registerChild(currentParent, key, node);\n      }\n\n      context.markCreated(node);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      currentParent.replaceChild(node, currentNode);\n      getData(currentParent).keyMapValid = false;\n    } else {\n      currentParent.insertBefore(node, currentNode);\n    }\n\n    currentNode = node;\n  };\n\n  /**\n   * Clears out any unvisited Nodes, as the corresponding virtual element\n   * functions were never called for them.\n   */\n  var clearUnvisitedDOM = function () {\n    var node = currentParent;\n    var data = getData(node);\n    var keyMap = data.keyMap;\n    var keyMapValid = data.keyMapValid;\n    var child = node.lastChild;\n    var key = undefined;\n\n    if (child === currentNode && keyMapValid) {\n      return;\n    }\n\n    if (data.attrs[symbols.placeholder] && node !== root) {\n      if ('production' !== 'production') {}\n      return;\n    }\n\n    while (child !== currentNode) {\n      node.removeChild(child);\n      context.markDeleted( /** @type {!Node}*/child);\n\n      key = getData(child).key;\n      if (key) {\n        delete keyMap[key];\n      }\n      child = node.lastChild;\n    }\n\n    // Clean the keyMap, removing any unusued keys.\n    if (!keyMapValid) {\n      for (key in keyMap) {\n        child = keyMap[key];\n        if (child.parentNode !== node) {\n          context.markDeleted(child);\n          delete keyMap[key];\n        }\n      }\n\n      data.keyMapValid = true;\n    }\n  };\n\n  /**\n   * Changes to the first child of the current node.\n   */\n  var enterNode = function () {\n    currentParent = currentNode;\n    currentNode = null;\n  };\n\n  /**\n   * Changes to the next sibling of the current node.\n   */\n  var nextNode = function () {\n    if (currentNode) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      currentNode = currentParent.firstChild;\n    }\n  };\n\n  /**\n   * Changes to the parent of the current node, removing any unvisited children.\n   */\n  var exitNode = function () {\n    clearUnvisitedDOM();\n\n    currentNode = currentParent;\n    currentParent = currentParent.parentNode;\n  };\n\n  /**\n   * Makes sure that the current node is an Element with a matching tagName and\n   * key.\n   *\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @return {!Element} The corresponding Element.\n   */\n  var coreElementOpen = function (tag, key, statics) {\n    nextNode();\n    alignWithDOM(tag, key, statics);\n    enterNode();\n    return (/** @type {!Element} */currentParent\n    );\n  };\n\n  /**\n   * Closes the currently open Element, removing any unvisited children if\n   * necessary.\n   *\n   * @return {!Element} The corresponding Element.\n   */\n  var coreElementClose = function () {\n    if ('production' !== 'production') {}\n\n    exitNode();\n    return (/** @type {!Element} */currentNode\n    );\n  };\n\n  /**\n   * Makes sure the current node is a Text node and creates a Text node if it is\n   * not.\n   *\n   * @return {!Text} The corresponding Text Node.\n   */\n  var coreText = function () {\n    nextNode();\n    alignWithDOM('#text', null, null);\n    return (/** @type {!Text} */currentNode\n    );\n  };\n\n  /**\n   * Gets the current Element being patched.\n   * @return {!Element}\n   */\n  var currentElement = function () {\n    if ('production' !== 'production') {}\n    return (/** @type {!Element} */currentParent\n    );\n  };\n\n  /**\n   * Skips the children in a subtree, allowing an Element to be closed without\n   * clearing out the children.\n   */\n  var skip = function () {\n    if ('production' !== 'production') {}\n    currentNode = currentParent.lastChild;\n  };\n\n  /**\n   * The offset in the virtual element declaration where the attributes are\n   * specified.\n   * @const\n   */\n  var ATTRIBUTES_OFFSET = 3;\n\n  /**\n   * Builds an array of arguments for use with elementOpenStart, attr and\n   * elementOpenEnd.\n   * @const {Array<*>}\n   */\n  var argsBuilder = [];\n\n  /**\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementOpen = function (tag, key, statics, const_args) {\n    if ('production' !== 'production') {}\n\n    var node = coreElementOpen(tag, key, statics);\n    var data = getData(node);\n\n    /*\n     * Checks to see if one or more attributes have changed for a given Element.\n     * When no attributes have changed, this is much faster than checking each\n     * individual argument. When attributes have changed, the overhead of this is\n     * minimal.\n     */\n    var attrsArr = data.attrsArr;\n    var newAttrs = data.newAttrs;\n    var attrsChanged = false;\n    var i = ATTRIBUTES_OFFSET;\n    var j = 0;\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      if (attrsArr[j] !== arguments[i]) {\n        attrsChanged = true;\n        break;\n      }\n    }\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsChanged = true;\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    if (attrsChanged) {\n      for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        newAttrs[arguments[i]] = arguments[i + 1];\n      }\n\n      for (var _attr in newAttrs) {\n        updateAttribute(node, _attr, newAttrs[_attr]);\n        newAttrs[_attr] = undefined;\n      }\n    }\n\n    return node;\n  };\n\n  /**\n   * Declares a virtual Element at the current location in the document. This\n   * corresponds to an opening tag and a elementClose tag is required. This is\n   * like elementOpen, but the attributes are defined using the attr function\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\n   * to attr, then a call to elementOpenEnd.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   */\n  var elementOpenStart = function (tag, key, statics) {\n    if ('production' !== 'production') {}\n\n    argsBuilder[0] = tag;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n  };\n\n  /***\n   * Defines a virtual attribute at this point of the DOM. This is only valid\n   * when called between elementOpenStart and elementOpenEnd.\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  var attr = function (name, value) {\n    if ('production' !== 'production') {}\n\n    argsBuilder.push(name, value);\n  };\n\n  /**\n   * Closes an open tag started with elementOpenStart.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementOpenEnd = function () {\n    if ('production' !== 'production') {}\n\n    var node = elementOpen.apply(null, argsBuilder);\n    argsBuilder.length = 0;\n    return node;\n  };\n\n  /**\n   * Closes an open virtual Element.\n   *\n   * @param {string} tag The element's tag.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementClose = function (tag) {\n    if ('production' !== 'production') {}\n\n    var node = coreElementClose();\n\n    if ('production' !== 'production') {}\n\n    return node;\n  };\n\n  /**\n   * Declares a virtual Element at the current location in the document that has\n   * no children.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementVoid = function (tag, key, statics, const_args) {\n    elementOpen.apply(null, arguments);\n    return elementClose(tag);\n  };\n\n  /**\n   * Declares a virtual Element at the current location in the document that is a\n   * placeholder element. Children of this Element can be manually managed and\n   * will not be cleared by the library.\n   *\n   * A key must be specified to make sure that this node is correctly preserved\n   * across all conditionals.\n   *\n   * @param {string} tag The element's tag.\n   * @param {string} key The key used to identify this element.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  var elementPlaceholder = function (tag, key, statics, const_args) {\n    if ('production' !== 'production') {}\n\n    elementOpen.apply(null, arguments);\n    skip();\n    return elementClose(tag);\n  };\n\n  /**\n   * Declares a virtual Text at this point in the document.\n   *\n   * @param {string|number|boolean} value The value of the Text.\n   * @param {...(function((string|number|boolean)):string)} const_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   * @return {!Text} The corresponding text node.\n   */\n  var text = function (value, const_args) {\n    if ('production' !== 'production') {}\n\n    var node = coreText();\n    var data = getData(node);\n\n    if (data.text !== value) {\n      data.text = /** @type {string} */value;\n\n      var formatted = value;\n      for (var i = 1; i < arguments.length; i += 1) {\n        /*\n         * Call the formatter function directly to prevent leaking arguments.\n         * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n         */\n        var fn = arguments[i];\n        formatted = fn(formatted);\n      }\n\n      node.data = formatted;\n    }\n\n    return node;\n  };\n\n  exports.patch = patchInner;\n  exports.patchInner = patchInner;\n  exports.patchOuter = patchOuter;\n  exports.currentElement = currentElement;\n  exports.skip = skip;\n  exports.elementVoid = elementVoid;\n  exports.elementOpenStart = elementOpenStart;\n  exports.elementOpenEnd = elementOpenEnd;\n  exports.elementOpen = elementOpen;\n  exports.elementClose = elementClose;\n  exports.elementPlaceholder = elementPlaceholder;\n  exports.text = text;\n  exports.attr = attr;\n  exports.symbols = symbols;\n  exports.attributes = attributes;\n  exports.applyAttr = applyAttr;\n  exports.applyProp = applyProp;\n  exports.notifications = notifications;\n\n}));\n"]}