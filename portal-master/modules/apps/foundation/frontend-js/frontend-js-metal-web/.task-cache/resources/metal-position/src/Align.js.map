{"version":3,"sources":["/source/Align.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport Position from './Position';\n\n/**\n * Align utility. Computes region or best region to align an element with\n * another. Regions are relative to viewport, make sure to use element with\n * position fixed, or position absolute when the element first positioned\n * parent is the body element.\n */\nclass Align {\n\n\t/**\n\t * Aligns the element with the best region around alignElement. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {string} The final chosen position for the aligned element.\n\t * @static\n\t */\n\tstatic align(element, alignElement, position) {\n\t\tvar suggestion = this.suggestAlignBestRegion(element, alignElement, position);\n\t\tvar bestRegion = suggestion.region;\n\n\t\tvar computedStyle = window.getComputedStyle(element, null);\n\t\tif (computedStyle.getPropertyValue('position') !== 'fixed') {\n\t\t\tbestRegion.top += window.pageYOffset;\n\t\t\tbestRegion.left += window.pageXOffset;\n\n\t\t\tvar offsetParent = element;\n\t\t\twhile ((offsetParent = offsetParent.offsetParent)) {\n\t\t\t\tbestRegion.top -= Position.getOffsetTop(offsetParent);\n\t\t\t\tbestRegion.left -= Position.getOffsetLeft(offsetParent);\n\t\t\t}\n\t\t}\n\n\t\telement.style.top = bestRegion.top + 'px';\n\t\telement.style.left = bestRegion.left + 'px';\n\t\treturn suggestion.position;\n\t}\n\n\t/**\n\t * Returns the best region to align element with alignElement. This is similar\n\t * to `Align.suggestAlignBestRegion`, but it only returns the region information,\n\t * while `Align.suggestAlignBestRegion` also returns the chosen position.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Best region to align element.\n\t * @static\n\t */\n\tstatic getAlignBestRegion(element, alignElement, position) {\n\t\treturn Align.suggestAlignBestRegion(element, alignElement, position).region;\n\t}\n\n\t/**\n\t * Returns the region to align element with alignElement. The element is\n\t * always aligned in the middle of alignElement axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The position to align. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {DOMRect} Region to align element.\n\t * @static\n\t */\n\tstatic getAlignRegion(element, alignElement, position) {\n\t\tvar r1 = Position.getRegion(alignElement);\n\t\tvar r2 = Position.getRegion(element);\n\t\tvar top = 0;\n\t\tvar left = 0;\n\n\t\tswitch (position) {\n\t\t\tcase Align.TopCenter:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.RightCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left + r1.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomCenter:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left + r1.width / 2 - r2.width / 2;\n\t\t\t\tbreak;\n\t\t\tcase Align.LeftCenter:\n\t\t\t\ttop = r1.top + r1.height / 2 - r2.height / 2;\n\t\t\t\tleft = r1.left - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopRight:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomRight:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.right - r2.width;\n\t\t\t\tbreak;\n\t\t\tcase Align.BottomLeft:\n\t\t\t\ttop = r1.bottom;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t\tcase Align.TopLeft:\n\t\t\t\ttop = r1.top - r2.height;\n\t\t\t\tleft = r1.left;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tbottom: top + r2.height,\n\t\t\theight: r2.height,\n\t\t\tleft: left,\n\t\t\tright: left + r2.width,\n\t\t\ttop: top,\n\t\t\twidth: r2.width\n\t\t};\n\t}\n\n\t/**\n\t * Checks if specified value is a valid position. Options `Align.Top`,\n\t *     `Align.Right`, `Align.Bottom`, `Align.Left`.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} val\n\t * @return {boolean} Returns true if value is a valid position.\n\t * @static\n\t */\n\tstatic isValidPosition(val) {\n\t\treturn 0 <= val && val <= 8;\n\t}\n\n\t/**\n\t * Looks for the best region for aligning the given element. The best\n\t * region is defined by clockwise rotation starting from the specified\n\t * `position`. The element is always aligned in the middle of alignElement\n\t * axis.\n\t * @param {!Element} element Element to be aligned.\n\t * @param {!Element} alignElement Element to align with.\n\t * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} pos\n\t *     The initial position to try. Options `Align.Top`, `Align.Right`,\n\t *     `Align.Bottom`, `Align.Left`.\n\t * @return {{position: string, region: DOMRect}} Best region to align element.\n\t * @static\n\t */\n\tstatic suggestAlignBestRegion(element, alignElement, position) {\n\t\tvar bestArea = 0;\n\t\tvar bestPosition = position;\n\t\tvar bestRegion = this.getAlignRegion(element, alignElement, bestPosition);\n\t\tvar tryPosition = bestPosition;\n\t\tvar tryRegion = bestRegion;\n\t\tvar viewportRegion = Position.getRegion(window);\n\n\t\tfor (var i = 0; i < 8;) {\n\t\t\tif (Position.intersectRegion(viewportRegion, tryRegion)) {\n\t\t\t\tvar visibleRegion = Position.intersection(viewportRegion, tryRegion);\n\t\t\t\tvar area = visibleRegion.width * visibleRegion.height;\n\t\t\t\tif (area > bestArea) {\n\t\t\t\t\tbestArea = area;\n\t\t\t\t\tbestRegion = tryRegion;\n\t\t\t\t\tbestPosition = tryPosition;\n\t\t\t\t}\n\t\t\t\tif (Position.insideViewport(tryRegion)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttryPosition = (position + (++i)) % 8;\n\t\t\ttryRegion = this.getAlignRegion(element, alignElement, tryPosition);\n\t\t}\n\n\t\treturn {\n\t\t\tposition: bestPosition,\n\t\t\tregion: bestRegion\n\t\t};\n\t}\n}\n\n/**\n * Constants that represent the supported positions for `Align`.\n * @type {number}\n * @static\n */\n\nAlign.TopCenter = 0;\nAlign.TopRight = 1;\nAlign.RightCenter = 2;\nAlign.BottomRight = 3;\nAlign.BottomCenter = 4;\nAlign.BottomLeft = 5;\nAlign.LeftCenter = 6;\nAlign.TopLeft = 7;\n\n/**\n * Aliases for position constants.\n * @type {number}\n * @static\n */\nAlign.Top = Align.TopCenter;\nAlign.Right = Align.RightCenter;\nAlign.Bottom = Align.BottomCenter;\nAlign.Left = Align.LeftCenter;\n\nexport default Align;\n"]}