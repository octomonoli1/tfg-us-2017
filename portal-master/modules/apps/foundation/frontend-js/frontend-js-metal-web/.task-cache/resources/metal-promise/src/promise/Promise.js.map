{"version":3,"sources":["/source/Promise.js"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Promises polyfill from Google's Closure Library.\n *\n *      Copyright 2013 The Closure Library Authors. All Rights Reserved.\n *\n * NOTE(eduardo): Promise support is not ready on all supported browsers,\n * therefore core.js is temporarily using Google's promises as polyfill. It\n * supports cancellable promises and has clean and fast implementation.\n */\n\n'use strict';\n\nimport { core } from 'metal';\nimport { async } from 'metal';\n\n/**\n * Provides a more strict interface for Thenables in terms of\n * http://promisesaplus.com for interop with {@see CancellablePromise}.\n *\n * @interface\n * @extends {IThenable.<TYPE>}\n * @template TYPE\n */\nvar Thenable = function() {};\n\n/**\n * Adds callbacks that will operate on the result of the Thenable, returning a\n * new child Promise.\n *\n * If the Thenable is fulfilled, the {@code onFulfilled} callback will be\n * invoked with the fulfillment value as argument, and the child Promise will\n * be fulfilled with the return value of the callback. If the callback throws\n * an exception, the child Promise will be rejected with the thrown value\n * instead.\n *\n * If the Thenable is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value of the callback or thrown value.\n *\n * @param {?(function(this:THIS, TYPE):\n *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fullfilled.\n * @param {?(function(*): *)=} opt_onRejected A function that will be invoked\n *     with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the\n *     result of the fulfillment or rejection callback.\n * @template RESULT,THIS\n */\nThenable.prototype.then = function() {};\n\n\n/**\n * An expando property to indicate that an object implements\n * {@code Thenable}.\n *\n * {@see addImplementation}.\n *\n * @const\n */\nThenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';\n\n\n/**\n * Marks a given class (constructor) as an implementation of Thenable, so\n * that we can query that fact at runtime. The class must have already\n * implemented the interface.\n * Exports a 'then' method on the constructor prototype, so that the objects\n * also implement the extern {@see Thenable} interface for interop with\n * other Promise implementations.\n * @param {function(new:Thenable,...[?])} ctor The class constructor. The\n *     corresponding class must have already implemented the interface.\n */\nThenable.addImplementation = function(ctor) {\n  ctor.prototype.then = ctor.prototype.then;\n  ctor.prototype.$goog_Thenable = true;\n};\n\n\n/**\n * @param {*} object\n * @return {boolean} Whether a given instance implements {@code Thenable}.\n *     The class/superclass of the instance must call {@code addImplementation}.\n */\nThenable.isImplementedBy = function(object) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object.$goog_Thenable;\n  } catch (e) {\n    // Property access seems to be forbidden.\n    return false;\n  }\n};\n\n\n/**\n * Like bind(), except that a 'this object' is not required. Useful when the\n * target function is already bound.\n *\n * Usage:\n * var g = partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n */\nvar partial = function(fn) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Clone the array (with slice()) and append additional arguments\n    // to the existing arguments.\n    var newArgs = args.slice();\n    newArgs.push.apply(newArgs, arguments);\n    return fn.apply(this, newArgs);\n  };\n};\n\n/**\n * Promises provide a result that may be resolved asynchronously. A Promise may\n * be resolved by being fulfilled or rejected with a value, which will be known\n * as the fulfillment value or the rejection reason. Whether fulfilled or\n * rejected, the Promise result is immutable once it is set.\n *\n * Promises may represent results of any type, including undefined. Rejection\n * reasons are typically Errors, but may also be of any type. Closure Promises\n * allow for optional type annotations that enforce that fulfillment values are\n * of the appropriate types at compile time.\n *\n * The result of a Promise is accessible by calling {@code then} and registering\n * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise\n * resolves, the relevant callbacks are invoked with the fulfillment value or\n * rejection reason as argument. Callbacks are always invoked in the order they\n * were registered, even when additional {@code then} calls are made from inside\n * another callback. A callback is always run asynchronously sometime after the\n * scope containing the registering {@code then} invocation has returned.\n *\n * If a Promise is resolved with another Promise, the first Promise will block\n * until the second is resolved, and then assumes the same result as the second\n * Promise. This allows Promises to depend on the results of other Promises,\n * linking together multiple asynchronous operations.\n *\n * This implementation is compatible with the Promises/A+ specification and\n * passes that specification's conformance test suite. A Closure Promise may be\n * resolved with a Promise instance (or sufficiently compatible Promise-like\n * object) created by other Promise implementations. From the specification,\n * Promise-like objects are known as \"Thenables\".\n *\n * @see http://promisesaplus.com/\n *\n * @param {function(\n *             this:RESOLVER_CONTEXT,\n *             function((TYPE|IThenable.<TYPE>|Thenable)),\n *             function(*)): void} resolver\n *     Initialization function that is invoked immediately with {@code resolve}\n *     and {@code reject} functions as arguments. The Promise is resolved or\n *     rejected with the first argument passed to either function.\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\n *     resolver function. If unspecified, the resolver function will be executed\n *     in the default scope.\n * @constructor\n * @struct\n * @final\n * @implements {Thenable.<TYPE>}\n * @template TYPE,RESOLVER_CONTEXT\n */\nvar CancellablePromise = function(resolver, opt_context) {\n  /**\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\n   * BLOCKED.\n   * @private {CancellablePromise.State_}\n   */\n  this.state_ = CancellablePromise.State_.PENDING;\n\n  /**\n   * The resolved result of the Promise. Immutable once set with either a\n   * fulfillment value or rejection reason.\n   * @private {*}\n   */\n  this.result_ = undefined;\n\n  /**\n   * For Promises created by calling {@code then()}, the originating parent.\n   * @private {CancellablePromise}\n   */\n  this.parent_ = null;\n\n  /**\n   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to\n   * this Promise by calls to {@code then()}.\n   * @private {Array.<CancellablePromise.CallbackEntry_>}\n   */\n  this.callbackEntries_ = null;\n\n  /**\n   * Whether the Promise is in the queue of Promises to execute.\n   * @private {boolean}\n   */\n  this.executing_ = false;\n\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    /**\n     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\n     * cleared only if an {@code onRejected} callback is invoked for the\n     * Promise (or one of its descendants) before the delay is exceeded.\n     *\n     * If the rejection is not handled before the timeout completes, the\n     * rejection reason is passed to the unhandled rejection handler.\n     * @private {number}\n     */\n    this.unhandledRejectionId_ = 0;\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    /**\n     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a\n     * boolean that is set if the Promise is rejected, and reset to false if an\n     * {@code onRejected} callback is invoked for the Promise (or one of its\n     * descendants). If the rejection is not handled before the next timestep,\n     * the rejection reason is passed to the unhandled rejection handler.\n     * @private {boolean}\n     */\n    this.hadUnhandledRejection_ = false;\n  }\n\n  try {\n    var self = this;\n    resolver.call(\n      opt_context, function(value) {\n        self.resolve_(CancellablePromise.State_.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(CancellablePromise.State_.REJECTED, reason);\n      });\n  } catch (e) {\n    this.resolve_(CancellablePromise.State_.REJECTED, e);\n  }\n};\n\n/**\n * The delay in milliseconds before a rejected Promise's reason is passed to\n * the rejection handler. By default, the rejection handler rethrows the\n * rejection reason so that it appears in the developer console or\n * {@code window.onerror} handler.\n * Rejections are rethrown as quickly as possible by default. A negative value\n * disables rejection handling entirely.\n * @type {number}\n */\nCancellablePromise.UNHANDLED_REJECTION_DELAY = 0;\n\n\n/**\n * The possible internal states for a Promise. These states are not directly\n * observable to external callers.\n * @enum {number}\n * @private\n */\nCancellablePromise.State_ = {\n  /** The Promise is waiting for resolution. */\n  PENDING: 0,\n\n  /** The Promise is blocked waiting for the result of another Thenable. */\n  BLOCKED: 1,\n\n  /** The Promise has been resolved with a fulfillment value. */\n  FULFILLED: 2,\n\n  /** The Promise has been resolved with a rejection reason. */\n  REJECTED: 3\n};\n\n\n/**\n * Typedef for entries in the callback chain. Each call to {@code then},\n * {@code thenCatch}, or {@code thenAlways} creates an entry containing the\n * functions that may be invoked once the Promise is resolved.\n *\n * @typedef {{\n *   child: CancellablePromise,\n *   onFulfilled: function(*),\n *   onRejected: function(*)\n * }}\n * @private\n */\nCancellablePromise.CallbackEntry_ = null;\n\n\n/**\n * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value\n * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved\n *     with the given value.\n * @template TYPE\n */\nCancellablePromise.resolve = function(opt_value) {\n  return new CancellablePromise(function(resolve) {\n      resolve(opt_value);\n    });\n};\n\n\n/**\n * @param {*=} opt_reason\n * @return {!CancellablePromise} A new Promise that is immediately rejected with the\n *     given reason.\n */\nCancellablePromise.reject = function(opt_reason) {\n  return new CancellablePromise(function(resolve, reject) {\n      reject(opt_reason);\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the\n *     first Promise (or Promise-like) input to complete.\n * @template TYPE\n */\nCancellablePromise.race = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      if (!promises.length) {\n        resolve(undefined);\n      }\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(resolve, reject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of\n *     every fulfilled value once every input Promise (or Promise-like) is\n *     successfully fulfilled, or is rejected by the first rejection result.\n * @template TYPE\n */\nCancellablePromise.all = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toFulfill = promises.length;\n      var values = [];\n\n      if (!toFulfill) {\n        resolve(values);\n        return;\n      }\n\n      var onFulfill = function(index, value) {\n        toFulfill--;\n        values[index] = value;\n        if (toFulfill === 0) {\n          resolve(values);\n        }\n      };\n\n      var onReject = function(reason) {\n        reject(reason);\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(partial(onFulfill, i), onReject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of\n *     the first input to be fulfilled, or is rejected with a list of every\n *     rejection reason if all inputs are rejected.\n * @template TYPE\n */\nCancellablePromise.firstFulfilled = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toReject = promises.length;\n      var reasons = [];\n\n      if (!toReject) {\n        resolve(undefined);\n        return;\n      }\n\n      var onFulfill = function(value) {\n        resolve(value);\n      };\n\n      var onReject = function(index, reason) {\n        toReject--;\n        reasons[index] = reason;\n        if (toReject === 0) {\n          reject(reasons);\n        }\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(onFulfill, partial(onReject, i));\n      }\n    });\n};\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise, returning a\n * new child Promise.\n *\n * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked\n * with the fulfillment value as argument, and the child Promise will be\n * fulfilled with the return value of the callback. If the callback throws an\n * exception, the child Promise will be rejected with the thrown value instead.\n *\n * If the Promise is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value (or thrown value) of the callback.\n *\n * @override\n */\nCancellablePromise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  return this.addChildPromise_(\n    core.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\n    core.isFunction(opt_onRejected) ? opt_onRejected : null,\n    opt_context);\n};\nThenable.addImplementation(CancellablePromise);\n\n\n/**\n * Adds a callback that will be invoked whether the Promise is fulfilled or\n * rejected. The callback receives no argument, and no new child Promise is\n * created. This is useful for ensuring that cleanup takes place after certain\n * asynchronous operations. Callbacks added with {@code thenAlways} will be\n * executed in the same order with other calls to {@code then},\n * {@code thenAlways}, or {@code thenCatch}.\n *\n * Since it does not produce a new child Promise, cancellation propagation is\n * not prevented by adding callbacks with {@code thenAlways}. A Promise that has\n * a cleanup handler added with {@code thenAlways} will be canceled if all of\n * its children created by {@code then} (or {@code thenCatch}) are canceled.\n *\n * @param {function(this:THIS): void} onResolved A function that will be invoked\n *     when the Promise is resolved.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.\n * @template THIS\n */\nCancellablePromise.prototype.thenAlways = function(onResolved, opt_context) {\n  var callback = function() {\n    try {\n      // Ensure that no arguments are passed to onResolved.\n      onResolved.call(opt_context);\n    } catch (err) {\n      CancellablePromise.handleRejection_.call(null, err);\n    }\n  };\n\n  this.addCallbackEntry_({\n    child: null,\n    onRejected: callback,\n    onFulfilled: callback\n  });\n  return this;\n};\n\n\n/**\n * Adds a callback that will be invoked only if the Promise is rejected. This\n * is equivalent to {@code then(null, onRejected)}.\n *\n * @param {!function(this:THIS, *): *} onRejected A function that will be\n *     invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise} A new Promise that will receive the result of the\n *     callback.\n * @template THIS\n */\nCancellablePromise.prototype.thenCatch = function(onRejected, opt_context) {\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\n\n/**\n * Alias of {@link CancellablePromise.prototype.thenCatch}\n */\nCancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;\n\n\n/**\n * Cancels the Promise if it is still pending by rejecting it with a cancel\n * Error. No action is performed if the Promise is already resolved.\n *\n * All child Promises of the canceled Promise will be rejected with the same\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\n * is the only child of a pending Promise, the parent Promise will also be\n * canceled. Cancellation may propagate upward through multiple generations.\n *\n * @param {string=} opt_message An optional debugging message for describing the\n *     cancellation reason.\n */\nCancellablePromise.prototype.cancel = function(opt_message) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    async.run(function() {\n      var err = new CancellablePromise.CancellationError(opt_message);\n      err.IS_CANCELLATION_ERROR = true;\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\n\n\n/**\n * Cancels this Promise with the given error.\n *\n * @param {!Error} err The cancellation error.\n * @private\n */\nCancellablePromise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    if (this.parent_) {\n      // Cancel the Promise and remove it from the parent's child list.\n      this.parent_.cancelChild_(this, err);\n    } else {\n      this.resolve_(CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Cancels a child Promise from the list of callback entries. If the Promise has\n * not already been resolved, reject it with a cancel error. If there are no\n * other children in the list of callback entries, propagate the cancellation\n * by canceling this Promise as well.\n *\n * @param {!CancellablePromise} childPromise The Promise to cancel.\n * @param {!Error} err The cancel error to use for rejecting the Promise.\n * @private\n */\nCancellablePromise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childIndex = -1;\n\n  // Find the callback entry for the childPromise, and count whether there are\n  // additional child Promises.\n  for (var i = 0, entry; (entry = this.callbackEntries_[i]); i++) {\n    var child = entry.child;\n    if (child) {\n      childCount++;\n      if (child === childPromise) {\n        childIndex = i;\n      }\n      if (childIndex >= 0 && childCount > 1) {\n        break;\n      }\n    }\n  }\n\n  // If the child Promise was the only child, cancel this Promise as well.\n  // Otherwise, reject only the child Promise with the cancel error.\n  if (childIndex >= 0) {\n    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {\n      this.cancelInternal_(err);\n    } else {\n      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];\n      this.executeCallback_(\n        callbackEntry, CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Adds a callback entry to the current Promise, and schedules callback\n * execution if the Promise has already been resolved.\n *\n * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing\n *     {@code onFulfilled} and {@code onRejected} callbacks to execute after\n *     the Promise is resolved.\n * @private\n */\nCancellablePromise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if ((!this.callbackEntries_ || !this.callbackEntries_.length) &&\n    (this.state_ === CancellablePromise.State_.FULFILLED ||\n    this.state_ === CancellablePromise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  if (!this.callbackEntries_) {\n    this.callbackEntries_ = [];\n  }\n  this.callbackEntries_.push(callbackEntry);\n};\n\n\n/**\n * Creates a child Promise and adds it to the callback entry list. The result of\n * the child Promise is determined by the state of the parent Promise and the\n * result of the {@code onFulfilled} or {@code onRejected} callbacks as\n * specified in the Promise resolution procedure.\n *\n * @see http://promisesaplus.com/#the__method\n *\n * @param {?function(this:THIS, TYPE):\n *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that\n *     will be invoked if the Promise is fullfilled, or null.\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\n *     invoked if the Promise is rejected, or null.\n * @param {THIS=} opt_context An optional execution context for the callbacks.\n *     in the default calling context.\n * @return {!CancellablePromise} The child Promise.\n * @template RESULT,THIS\n * @private\n */\nCancellablePromise.prototype.addChildPromise_ = function(\nonFulfilled, onRejected, opt_context) {\n\n  var callbackEntry = {\n    child: null,\n    onFulfilled: null,\n    onRejected: null\n  };\n\n  callbackEntry.child = new CancellablePromise(function(resolve, reject) {\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n\n    // Invoke onRejected, or reject with the parent's reason if absent.\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (!core.isDef(result) && reason.IS_CANCELLATION_ERROR) {\n          // Propagate cancellation to children if no other result is returned.\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(\n    /** @type {CancellablePromise.CallbackEntry_} */ (callbackEntry));\n  return callbackEntry.child;\n};\n\n\n/**\n * Unblocks the Promise and fulfills it with the given value.\n *\n * @param {TYPE} value\n * @private\n */\nCancellablePromise.prototype.unblockAndFulfill_ = function(value) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.FULFILLED, value);\n};\n\n\n/**\n * Unblocks the Promise and rejects it with the given rejection reason.\n *\n * @param {*} reason\n * @private\n */\nCancellablePromise.prototype.unblockAndReject_ = function(reason) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.REJECTED, reason);\n};\n\n\n/**\n * Attempts to resolve a Promise with a given resolution state and value. This\n * is a no-op if the given Promise has already been resolved.\n *\n * If the given result is a Thenable (such as another Promise), the Promise will\n * be resolved with the same state and result as the Thenable once it is itself\n * resolved.\n *\n * If the given result is not a Thenable, the Promise will be fulfilled or\n * rejected with that result based on the given state.\n *\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\n *\n * @param {CancellablePromise.State_} state\n * @param {*} x The result to apply to the Promise.\n * @private\n */\nCancellablePromise.prototype.resolve_ = function(state, x) {\n  if (this.state_ !== CancellablePromise.State_.PENDING) {\n    return;\n  }\n\n  if (this === x) {\n    state = CancellablePromise.State_.REJECTED;\n    x = new TypeError('CancellablePromise cannot resolve to itself');\n\n  } else if (Thenable.isImplementedBy(x)) {\n    x = /** @type {!Thenable} */ (x);\n    this.state_ = CancellablePromise.State_.BLOCKED;\n    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);\n    return;\n\n  } else if (core.isObject(x)) {\n    try {\n      var then = x.then;\n      if (core.isFunction(then)) {\n        this.tryThen_(x, then);\n        return;\n      }\n    } catch (e) {\n      state = CancellablePromise.State_.REJECTED;\n      x = e;\n    }\n  }\n\n  this.result_ = x;\n  this.state_ = state;\n  this.scheduleCallbacks_();\n\n  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {\n    CancellablePromise.addUnhandledRejection_(this, x);\n  }\n};\n\n\n/**\n * Attempts to call the {@code then} method on an object in the hopes that it is\n * a Promise-compatible instance. This allows interoperation between different\n * Promise implementations, however a non-compliant object may cause a Promise\n * to hang indefinitely. If the {@code then} method throws an exception, the\n * dependent Promise will be rejected with the thrown value.\n *\n * @see http://promisesaplus.com/#point-70\n *\n * @param {Thenable} thenable An object with a {@code then} method that may be\n *     compatible with the Promise/A+ specification.\n * @param {!Function} then The {@code then} method of the Thenable object.\n * @private\n */\nCancellablePromise.prototype.tryThen_ = function(thenable, then) {\n  this.state_ = CancellablePromise.State_.BLOCKED;\n  var promise = this;\n  var called = false;\n\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      promise.unblockAndFulfill_(value);\n    }\n  };\n\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      promise.unblockAndReject_(reason);\n    }\n  };\n\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\n\n\n/**\n * Executes the pending callbacks of a resolved Promise after a timeout.\n *\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\n * callbacks must only be invoked from a call stack that only contains Promise\n * implementation code, which we accomplish by invoking callback execution after\n * a timeout. If {@code startExecution_} is called multiple times for the same\n * Promise, the callback chain will be evaluated only once. Additional callbacks\n * may be added during the evaluation phase, and will be executed in the same\n * event loop.\n *\n * All Promises added to the waiting list during the same browser event loop\n * will be executed in one batch to avoid using a separate timeout per Promise.\n *\n * @private\n */\nCancellablePromise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    async.run(this.executeCallbacks_, this);\n  }\n};\n\n\n/**\n * Executes all pending callbacks for this Promise.\n *\n * @private\n */\nCancellablePromise.prototype.executeCallbacks_ = function() {\n  while (this.callbackEntries_ && this.callbackEntries_.length) {\n    var entries = this.callbackEntries_;\n    this.callbackEntries_ = [];\n\n    for (var i = 0; i < entries.length; i++) {\n      this.executeCallback_(entries[i], this.state_, this.result_);\n    }\n  }\n  this.executing_ = false;\n};\n\n\n/**\n * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}\n * or {@code onRejected} callback based on the resolved state of the Promise.\n *\n * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the\n *     onFulfilled and/or onRejected callbacks for this step.\n * @param {CancellablePromise.State_} state The resolution status of the Promise,\n *     either FULFILLED or REJECTED.\n * @param {*} result The resolved result of the Promise.\n * @private\n */\nCancellablePromise.prototype.executeCallback_ = function(\ncallbackEntry, state, result) {\n  if (state === CancellablePromise.State_.FULFILLED) {\n    callbackEntry.onFulfilled(result);\n  } else {\n    this.removeUnhandledRejection_();\n    callbackEntry.onRejected(result);\n  }\n};\n\n\n/**\n * Marks this rejected Promise as having being handled. Also marks any parent\n * Promises in the rejected state as handled. The rejection handler will no\n * longer be invoked for this Promise (if it has not been called already).\n *\n * @private\n */\nCancellablePromise.prototype.removeUnhandledRejection_ = function() {\n  var p;\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n      p.hadUnhandledRejection_ = false;\n    }\n  }\n};\n\n\n/**\n * Marks this rejected Promise as unhandled. If no {@code onRejected} callback\n * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}\n * expires, the reason will be passed to the unhandled rejection handler. The\n * handler typically rethrows the rejection reason so that it becomes visible in\n * the developer console.\n *\n * @param {!CancellablePromise} promise The rejected Promise.\n * @param {*} reason The Promise rejection reason.\n * @private\n */\nCancellablePromise.addUnhandledRejection_ = function(promise, reason) {\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = setTimeout(function() {\n      CancellablePromise.handleRejection_.call(null, reason);\n    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);\n\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    promise.hadUnhandledRejection_ = true;\n    async.run(function() {\n      if (promise.hadUnhandledRejection_) {\n        CancellablePromise.handleRejection_.call(null, reason);\n      }\n    });\n  }\n};\n\n\n/**\n * A method that is invoked with the rejection reasons for Promises that are\n * rejected but have no {@code onRejected} callbacks registered yet.\n * @type {function(*)}\n * @private\n */\nCancellablePromise.handleRejection_ = async.throwException;\n\n\n/**\n * Sets a handler that will be called with reasons from unhandled rejected\n * Promises. If the rejected Promise (or one of its descendants) has an\n * {@code onRejected} callback registered, the rejection will be considered\n * handled, and the rejection handler will not be called.\n *\n * By default, unhandled rejections are rethrown so that the error may be\n * captured by the developer console or a {@code window.onerror} handler.\n *\n * @param {function(*)} handler A function that will be called with reasons from\n *     rejected Promises. Defaults to {@code async.throwException}.\n */\nCancellablePromise.setUnhandledRejectionHandler = function(handler) {\n  CancellablePromise.handleRejection_ = handler;\n};\n\n\n\n/**\n * Error used as a rejection reason for canceled Promises.\n *\n * @param {string=} opt_message\n * @constructor\n * @extends {Error}\n * @final\n */\nCancellablePromise.CancellationError = class extends Error {\n  constructor(opt_message) {\n     super(opt_message);\n\n     if (opt_message) {\n       this.message = opt_message;\n     }\n   }\n};\n\n/** @override */\nCancellablePromise.CancellationError.prototype.name = 'cancel';\n\nexport {CancellablePromise};\nexport default CancellablePromise;\n"]}