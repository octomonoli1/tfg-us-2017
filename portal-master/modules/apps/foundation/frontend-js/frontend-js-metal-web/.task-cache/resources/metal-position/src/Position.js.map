{"version":3,"sources":["/source/Position.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport Geometry from './Geometry';\n\n/**\n * Class with static methods responsible for doing browser position checks.\n */\nclass Position {\n\t/**\n\t * Gets the client height of the specified node. Scroll height is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientHeight(node) {\n\t\treturn this.getClientSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the client height or width of the specified node. Scroll height is\n\t * not included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getClientSize_(node, prop) {\n\t\tvar el = node;\n\t\tif (core.isWindow(node)) {\n\t\t\tel = node.document.documentElement;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tel = node.documentElement;\n\t\t}\n\t\treturn el['client' + prop];\n\t}\n\n\t/**\n\t * Gets the client width of the specified node. Scroll width is not\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getClientWidth(node) {\n\t\treturn this.getClientSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Gets the region of the element, document or window.\n\t * @param {Element|Document|Window=} opt_element Optional element to test.\n\t * @return {!DOMRect} The returned value is a simulated DOMRect object which\n\t *     is the union of the rectangles returned by getClientRects() for the\n\t *     element, i.e., the CSS border-boxes associated with the element.\n\t * @protected\n\t */\n\tstatic getDocumentRegion_(opt_element) {\n\t\tvar height = this.getHeight(opt_element);\n\t\tvar width = this.getWidth(opt_element);\n\t\treturn this.makeRegion(height, height, 0, width, 0, width);\n\t}\n\n\t/**\n\t * Gets the height of the specified node. Scroll height is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getHeight(node) {\n\t\treturn this.getSize_(node, 'Height');\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetLeft` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetLeft` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetLeft(node, opt_ignoreTransform) {\n\t\treturn node.offsetLeft + (opt_ignoreTransform ? 0 : Position.getTranslation(node).left);\n\t}\n\n\t/**\n\t * Gets the top offset position of the given node. This fixes the `offsetTop` value of\n\t * nodes that were translated, which don't take that into account at all. That makes\n\t * the calculation more expensive though, so if you don't want that to be considered\n\t * either pass `opt_ignoreTransform` as true or call `offsetTop` directly on the node.\n\t * @param {!Element} node\n\t * @param {boolean=} opt_ignoreTransform When set to true will ignore transform css\n\t *   when calculating the position. Defaults to false.\n\t * @return {number}\n\t */\n\tstatic getOffsetTop(node, opt_ignoreTransform) {\n\t\treturn node.offsetTop + (opt_ignoreTransform ? 0 : Position.getTranslation(node).top);\n\t}\n\n\t/**\n\t * Gets the size of an element and its position relative to the viewport.\n\t * @param {!Document|Element|Window} node\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic getRegion(node, opt_includeScroll) {\n\t\tif (core.isDocument(node) || core.isWindow(node)) {\n\t\t\treturn this.getDocumentRegion_(node);\n\t\t}\n\t\treturn this.makeRegionFromBoundingRect_(node.getBoundingClientRect(), opt_includeScroll);\n\t}\n\n\t/**\n\t * Gets the scroll left position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollLeft(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageXOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageXOffset;\n\t\t}\n\t\treturn node.scrollLeft;\n\t}\n\n\t/**\n\t * Gets the scroll top position of the specified node.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getScrollTop(node) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn node.pageYOffset;\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\treturn node.defaultView.pageYOffset;\n\t\t}\n\t\treturn node.scrollTop;\n\t}\n\n\t/**\n\t * Gets the height or width of the specified node. Scroll height is\n\t * included.\n\t * @param {Element|Document|Window=} node\n\t * @param {string} `Width` or `Height` property.\n\t * @return {number}\n\t * @protected\n\t */\n\tstatic getSize_(node, prop) {\n\t\tif (core.isWindow(node)) {\n\t\t\treturn this.getClientSize_(node, prop);\n\t\t}\n\t\tif (core.isDocument(node)) {\n\t\t\tvar docEl = node.documentElement;\n\t\t\treturn Math.max(\n\t\t\t\tnode.body['scroll' + prop], docEl['scroll' + prop],\n\t\t\t\tnode.body['offset' + prop], docEl['offset' + prop], docEl['client' + prop]);\n\t\t}\n\t\treturn Math.max(node['client' + prop], node['scroll' + prop], node['offset' + prop]);\n\t}\n\n\t/**\n\t * Gets the transform matrix values for the given node.\n\t * @param {!Element} node\n\t * @return {Array<number>}\n\t */\n\tstatic getTransformMatrixValues(node) {\n\t\tvar style = getComputedStyle(node);\n\t\tvar transform = style.msTransform || style.transform || style.webkitTransform || style.mozTransform;\n\t\tif (transform !== 'none') {\n\t\t\tvar values = [];\n\t\t\tvar regex = /([\\d-\\.\\s]+)/g;\n\t\t\tvar matches = regex.exec(transform);\n\t\t\twhile (matches) {\n\t\t\t\tvalues.push(matches[1]);\n\t\t\t\tmatches = regex.exec(transform);\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the number of translated pixels for the given node, for both the top and\n\t * left positions.\n\t * @param {!Element} node\n\t * @return {number}\n\t */\n\tstatic getTranslation(node) {\n\t\tvar values = Position.getTransformMatrixValues(node);\n\t\tvar translation = {\n\t\t\tleft: 0,\n\t\t\ttop: 0\n\t\t};\n\t\tif (values) {\n\t\t\ttranslation.left = parseFloat(values.length === 6 ? values[4] : values[13]);\n\t\t\ttranslation.top = parseFloat(values.length === 6 ? values[5] : values[14]);\n\t\t}\n\t\treturn translation;\n\t}\n\n\t/**\n\t * Gets the width of the specified node. Scroll width is included.\n\t * @param {Element|Document|Window=} node\n\t * @return {number}\n\t */\n\tstatic getWidth(node) {\n\t\treturn this.getSize_(node, 'Width');\n\t}\n\n\t/**\n\t * Tests if a region intersects with another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic intersectRegion(r1, r2) {\n\t\treturn Geometry.intersectRect(\n\t\t\tr1.top, r1.left, r1.bottom, r1.right,\n\t\t\tr2.top, r2.left, r2.bottom, r2.right);\n\t}\n\n\t/**\n\t * Tests if a region is inside another.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {boolean}\n\t */\n\tstatic insideRegion(r1, r2) {\n\t\treturn (r2.top >= r1.top) && (r2.bottom <= r1.bottom) &&\n\t\t\t(r2.right <= r1.right) && (r2.left >= r1.left);\n\t}\n\n\t/**\n\t * Tests if a region is inside viewport region.\n\t * @param {DOMRect} region\n\t * @return {boolean}\n\t */\n\tstatic insideViewport(region) {\n\t\treturn this.insideRegion(this.getRegion(window), region);\n\t}\n\n\t/**\n\t * Computes the intersection region between two regions.\n\t * @param {DOMRect} r1\n\t * @param {DOMRect} r2\n\t * @return {?DOMRect} Intersection region or null if regions doesn't\n\t *     intersects.\n\t */\n\tstatic intersection(r1, r2) {\n\t\tif (!this.intersectRegion(r1, r2)) {\n\t\t\treturn null;\n\t\t}\n\t\tvar bottom = Math.min(r1.bottom, r2.bottom);\n\t\tvar right = Math.min(r1.right, r2.right);\n\t\tvar left = Math.max(r1.left, r2.left);\n\t\tvar top = Math.max(r1.top, r2.top);\n\t\treturn this.makeRegion(bottom, bottom - top, left, right, top, right - left);\n\t}\n\n\t/**\n\t * Makes a region object. It's a writable version of DOMRect.\n\t * @param {number} bottom\n\t * @param {number} height\n\t * @param {number} left\n\t * @param {number} right\n\t * @param {number} top\n\t * @param {number} width\n\t * @return {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t */\n\tstatic makeRegion(bottom, height, left, right, top, width) {\n\t\treturn {\n\t\t\tbottom: bottom,\n\t\t\theight: height,\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\ttop: top,\n\t\t\twidth: width\n\t\t};\n\t}\n\n\t/**\n\t * Makes a region from a DOMRect result from `getBoundingClientRect`.\n\t * @param  {!DOMRect} The returned value is a DOMRect object which is the\n\t *     union of the rectangles returned by getClientRects() for the element,\n\t *     i.e., the CSS border-boxes associated with the element.\n\t * @param {boolean=} opt_includeScroll Flag indicating if the document scroll\n\t *   position should be considered in the element's region coordinates. Defaults\n\t *   to false.\n\t * @return {DOMRect} Writable version of DOMRect.\n\t * @protected\n\t */\n\tstatic makeRegionFromBoundingRect_(rect, opt_includeScroll) {\n\t\tvar deltaX = opt_includeScroll ? Position.getScrollLeft(document) : 0;\n\t\tvar deltaY = opt_includeScroll ? Position.getScrollTop(document) : 0;\n\t\treturn this.makeRegion(\n\t\t\trect.bottom + deltaY,\n\t\t\trect.height,\n\t\t\trect.left + deltaX,\n\t\t\trect.right + deltaX,\n\t\t\trect.top + deltaY,\n\t\t\trect.width\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the given point coordinates are inside a region.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {!Object} region\n\t * @return {boolean}\n\t */\n\tstatic pointInsideRegion(x, y, region) {\n\t\treturn Position.insideRegion(region, Position.makeRegion(y, 0, x, x, y, 0));\n\t}\n}\n\nexport default Position;\n"]}