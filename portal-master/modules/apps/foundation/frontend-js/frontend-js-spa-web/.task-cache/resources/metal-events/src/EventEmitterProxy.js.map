{"version":3,"sources":["/source/EventEmitterProxy.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport { array, Disposable } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist || {};\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * A list of events that are pending to be listened by an actual origin\n\t\t * emitter. Events are stored here when the origin doesn't exist, so they\n\t\t * can be set on a new origin when one is set.\n\t\t * @type {!Array}\n\t\t * @protected\n\t\t */\n\t\tthis.pendingEvents_ = [];\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object<string, !EventHandle>}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = {};\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the given listener for the given event.\n\t * @param {string} event\n\t * @param {!function()} listener\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListener_(event, listener) {\n\t\treturn this.originEmitter_.on(event, listener);\n\t}\n\n\t/**\n\t * Adds the proxy listener for the given event.\n\t * @param {string} event\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListenerForEvent_(event) {\n\t\treturn this.addListener_(event, this.emitOnTarget_.bind(this, event));\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.removeListeners_();\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Emits the specified event type on the target emitter.\n\t * @param {string} eventType\n\t * @protected\n\t */\n\temitOnTarget_(eventType) {\n\t\tvar args = [eventType].concat(array.slice(arguments, 1));\n\t\tthis.targetEmitter_.emit.apply(this.targetEmitter_, args);\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent(event) {\n\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\tthis.tryToAddListener_(event);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the proxy listener for all events.\n\t * @protected\n\t */\n\tremoveListeners_() {\n\t\tvar events = Object.keys(this.proxiedEvents_);\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t}\n\t\tthis.proxiedEvents_ = {};\n\t\tthis.pendingEvents_ = [];\n\t}\n\n\t/**\n\t * Changes the origin emitter. This automatically detaches any events that\n\t * were already being proxied from the previous emitter, and starts proxying\n\t * them on the new emitter instead.\n\t * @param {!EventEmitter} originEmitter\n\t */\n\tsetOriginEmitter(originEmitter) {\n\t\tvar events = this.originEmitter_?\n\t\t\tObject.keys(this.proxiedEvents_) :\n\t\t\tthis.pendingEvents_;\n\t\tthis.removeListeners_();\n\t\tthis.originEmitter_ = originEmitter;\n\t\tevents.forEach(event => this.proxyEvent(event));\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.on('newListener', this.proxyEvent.bind(this));\n\t}\n\n\t/**\n\t * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n\t * the pending listener so it can be used on a future origin emitter.\n\t * @param {string} event\n\t * @protected\n\t */\n\ttryToAddListener_(event) {\n\t\tif (this.originEmitter_) {\n\t\t\tthis.proxiedEvents_[event] = this.addListenerForEvent_(event);\n\t\t} else {\n\t\t\tthis.pendingEvents_.push(event);\n\t\t}\n\t}\n}\n\nexport default EventEmitterProxy;\n"]}