{"version":3,"sources":["/source/Screen.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAOM,M;;;;;;;;;;;AASL,oBAAc;AAAA;;AAAA,gDACb,qBADa;;;;;;;AAQb,SAAK,EAAL,GAAU,MAAK,OAAL,CAAa,YAAK,MAAL,EAAb,CAAV;;;;;;;;;AASA,SAAK,KAAL,GAAa,IAAb;AAjBa;AAkBb;;;;;;;;mBAMD,Q,uBAAW;AACV;AACA,G;;mBAUD,gB,+BAAmB;AAClB;AACA,G;;mBAOD,uB,oCAAwB,I,EAAM;AAC7B,UAAO,IAAP;AACA,G;;mBAOD,wB,qCAAyB,K,EAAO;AAC/B,UAAO,KAAP;AACA,G;;mBAOD,U,yBAAa;AACZ;AACA,G;;mBAOD,e,8BAAkB;AACjB,wBAAM,eAAN;AACA;AACA,G;;mBASD,e,4BAAgB,Q,EAAU;AACzB,UAAO,IAAP,CAAY,QAAZ,EAAsB,OAAtB,CAA8B,eAAO;AACpC,QAAI,SAAS,GAAT,EAAc,WAAlB,EAA+B;AAC9B,qBAAW,mBAAX,CAA+B,SAAS,GAAT,EAAc,WAA7C;AACA;AACD,IAJD;AAKA,UAAO,kBAAmB,OAAnB,EAAP;AACA,G;;mBASD,c,6BAAiB;AAChB,UAAO,kBAAmB,OAAnB,EAAP;AACA,G;;mBASD,I,iBAAK,Q,EAAU;AAAA;;AACd;;AAEA,OAAI,cAAc,EAAlB;;AAEA,UAAO,IAAP,CAAY,QAAZ,EAAsB,OAAtB,CAA8B,eAAO;AACpC,QAAI,UAAU,SAAS,GAAT,CAAd;AACA,QAAI,WAAW,QAAQ,IAAR,CAAa,OAAK,EAAlB,CAAf;AACA,gBAAY,IAAZ,CAAiB,QAAjB;AACA,IAJD;;AAMA,UAAO,kBAAmB,GAAnB,CAAuB,WAAvB,CAAP;AACA,G;;mBAMD,K,oBAAQ;AACP,UAAO,KAAK,EAAZ;AACA,G;;mBAWD,iB,gCAAoB;AACnB;AACA,G;;mBAMD,Q,uBAAW;AACV,UAAO,KAAK,KAAZ;AACA,G;;mBAWD,I,mBAAO;AACN;AACA,UAAO,kBAAmB,OAAnB,EAAP;AACA,G;;mBAQD,O,oBAAQ,E,EAAI;AACX,UAAO,YAAY,EAAnB;AACA,G;;mBAMD,K,kBAAM,E,EAAI;AACT,QAAK,EAAL,GAAU,EAAV;AACA,G;;mBAMD,Q,qBAAS,K,EAAO;AACf,QAAK,KAAL,GAAa,KAAb;AACA,G;;mBAKD,Q,uBAAW;AACV,UAAO,KAAK,EAAZ;AACA,G;;;;;;;;;;AASF,QAAO,eAAP,GAAyB,UAAS,MAAT,EAAiB;AACzC,SAAO,kBAAkB,MAAzB;AACA,EAFD;;mBAIe,M","sourcesContent":["'use strict';\n\nimport { core } from 'metal';\nimport { globalEval } from 'metal-dom';\nimport Cacheable from '../cacheable/Cacheable';\nimport CancellablePromise from 'metal-promise';\n\nclass Screen extends Cacheable {\n\n\t/**\n\t * Screen class is a special type of route handler that provides helper\n\t * utilities that adds lifecycle and methods to provide content to each\n\t * registered surface.\n\t * @constructor\n\t * @extends {Cacheable}\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds the screen id.\n\t\t * @type {string}\n\t\t * @protected\n\t\t */\n\t\tthis.id = this.makeId_(core.getUid());\n\n\t\t/**\n\t\t * Holds the screen title. Relevant when the page title should be\n\t\t * upadated when screen is rendered.\n\t\t * @type {?string=}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis.title = null;\n\t}\n\n\t/**\n\t * Fires when the screen is active. Allows a screen to perform any setup\n\t * that requires its DOM to be visible. Lifecycle.\n\t */\n\tactivate() {\n\t\tconsole.log('Screen [' + this + '] activate');\n\t}\n\n\t/**\n\t * Gives the Screen a chance to cancel the navigation and stop itself from\n\t * being deactivated. Can be used, for example, if the screen has unsaved\n\t * state. Lifecycle. Clean-up should not be preformed here, since the\n\t * navigation may still be cancelled. Do clean-up in deactivate.\n\t * @return {boolean=} If returns true, the current screen is locked and the\n\t *     next nagivation interrupted.\n\t */\n\tbeforeDeactivate() {\n\t\tconsole.log('Screen [' + this + '] beforeDeactivate');\n\t}\n\n\t/**\n\t * Gives the Screen a chance format the path before history update.\n\t * @path {!string} path Navigation path.\n\t * @return {!string} Navigation path to use on history.\n\t */\n\tbeforeUpdateHistoryPath(path) {\n\t\treturn path;\n\t}\n\n\t/**\n\t * Gives the Screen a chance format the state before history update.\n\t * @path {!object} state History state.\n\t * @return {!object} History state to use on history.\n\t */\n\tbeforeUpdateHistoryState(state) {\n\t\treturn state;\n\t}\n\n\t/**\n\t * Allows a screen to do any cleanup necessary after it has been\n\t * deactivated, for example cancelling outstanding requests or stopping\n\t * timers. Lifecycle.\n\t */\n\tdeactivate() {\n\t\tconsole.log('Screen [' + this + '] deactivate');\n\t}\n\n\t/**\n\t * Dispose a screen, either after it is deactivated (in the case of a\n\t * non-cacheable view) or when the App is itself disposed for whatever\n\t * reason. Lifecycle.\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tconsole.log('Screen [' + this + '] dispose');\n\t}\n\n\t/**\n\t * Allows a screen to evaluate scripts before the element is made visible.\n\t * Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will\n\t *     pause the navigation until it is resolved.\n\t */\n\tevaluateScripts(surfaces) {\n\t\tObject.keys(surfaces).forEach(sId => {\n\t\t\tif (surfaces[sId].activeChild) {\n\t\t\t\tglobalEval.runScriptsInElement(surfaces[sId].activeChild);\n\t\t\t}\n\t\t});\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Allows a screen to evaluate styles before the element is made visible.\n\t * Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will\n\t *     pause the navigation until it is resolved.\n\t */\n\tevaluateStyles() {\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Allows a screen to perform any setup immediately before the element is\n\t * made visible. Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will pause the\n\t *     navigation until it is resolved.\n\t */\n\tflip(surfaces) {\n\t\tconsole.log('Screen [' + this + '] flip');\n\n\t\tvar transitions = [];\n\n\t\tObject.keys(surfaces).forEach(sId => {\n\t\t\tvar surface = surfaces[sId];\n\t\t\tvar deferred = surface.show(this.id);\n\t\t\ttransitions.push(deferred);\n\t\t});\n\n\t\treturn CancellablePromise.all(transitions);\n\t}\n\n\t/**\n\t * Gets the screen id.\n\t * @return {string}\n\t */\n\tgetId() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * Returns the content for the given surface, or null if the surface isn't\n\t * used by this screen. This will be called when a screen is initially\n\t * constructed or, if a screen is non-cacheable, when navigated.\n\t * @param {!string} surfaceId The id of the surface DOM element.\n\t * @return {?string|Element=} This can return a string or node representing\n\t *     the content of the surface. If returns falsy values surface default\n\t *     content is restored.\n\t */\n\tgetSurfaceContent() {\n\t\tconsole.log('Screen [' + this + '] getSurfaceContent');\n\t}\n\n\t/**\n\t * Gets the screen title.\n\t * @return {?string=}\n\t */\n\tgetTitle() {\n\t\treturn this.title;\n\t}\n\n\t/**\n\t * Returns all contents for the surfaces. This will pass the loaded content\n\t * to <code>Screen.load</code> with all information you\n\t * need to fulfill the surfaces. Lifecycle.\n\t * @param {!string=} path The requested path.\n\t * @return {!CancellablePromise} This can return a string representing the\n\t *     contents of the surfaces or a promise, which will pause the navigation\n\t *     until it is resolved. This is useful for loading async content.\n\t */\n\tload() {\n\t\tconsole.log('Screen [' + this + '] load');\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Makes the id for the screen.\n\t * @param {!string} id The screen id the content belongs too.\n\t * @return {string}\n\t * @private\n\t */\n\tmakeId_(id) {\n\t\treturn 'screen_' + id;\n\t}\n\n\t/**\n\t * Sets the screen id.\n\t * @param {!string} id\n\t */\n\tsetId(id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Sets the screen title.\n\t * @param {?string=} title\n\t */\n\tsetTitle(title) {\n\t\tthis.title = title;\n\t}\n\n\t/**\n\t * @return {string}\n\t */\n\ttoString() {\n\t\treturn this.id;\n\t}\n\n}\n\n/**\n * @param {*} object\n * @return {boolean} Whether a given instance implements\n * <code>Screen</code>.\n */\nScreen.isImplementedBy = function(object) {\n\treturn object instanceof Screen;\n};\n\nexport default Screen;\n"]}